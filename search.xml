<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU1323]]></title>
    <url>%2F2018%2F09%2F06%2FHDU1232%2F</url>
    <content type="text"><![CDATA[畅通工程Time Limit: 4000/2000 MS (Java/Others)Memory Limit: 65536/32768 K (Java/Others) Problem Description：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input：测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说 3 3 1 2 1 2 2 1 这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output：对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 2 1 3 4 3 3 3 1 2 1 3 2 3 5 2 1 2 3 5 999 0 0 Sample Output1 0 2 998]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集详解]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集（Union-find Sets）是一种非常巧妙而且实用的数据结构，主要用于处理一些不想交的集合合并问题。具体包含了两个函数：Union()用来合并和Find()用来查找 以及一个整型数组用来记录每个点的前导点是什么。 代码实现int pre[1050]//记录第i个节点的父亲节点 int Find(int root)//查找根节点 { int son,temp; son=root; while(root != pre[root]){//寻找父亲节点 root = pre[root]; } while(son != root){//路径压缩 temp=pre[son]; pre[son]=root; son=temp; } return son; } void Union(int root1,int root2){//判断是否连通，不连通就合并 int x,y; x=Find(root1); y=Find(root2); if(x!=y)//如果不连通，就把它们所在的连通分支合并 pre[x] = y; } 算法详解pre[]数组最开始初始化为为pre[i]=i，即表明这pre[i]的父亲节点是i，Union()函数则是将两个节点进行联通，其中Union中用到了Find()函数是找自己的父亲节点判断是否联通，如果不连通就进行pre[x]=y操作，表示为将x节点的父亲节点设置为y。其中Find()函数通过递归判断本节点的上一节点的父亲节点是不是本身，直到找到一个节点的父亲节点是本身的节点作为父亲节点。 在Find()函数中有一个路径压缩算法，是由于Union()函数只是为了连接，所以谁作为父亲节点是随机的，因此最后的树状结构可能很复杂，查找的效率就很低，那么就需要进行路径压缩，让所有的父子节点关系都变成两级结构。 经典例题传送门： HDU 1232畅通工程]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Jos’s blog! This is my first post.]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>hi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数塔]]></title>
    <url>%2F2017%2F09%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92--%E6%95%B0%E5%A1%94%2F</url>
    <content type="text"><![CDATA[数塔是动态规划的一道经典题认识数塔前，先认识一下动态规划，动态规划不是一种特定的算法，而是一种具有较强的技巧性的手段，或者说是思想，但所有动态规划的题离不开两个核心：1.状态2.状态转移方程当我们抓住这两个核心，我们的问题就能解决一大半！—————————————————————————————————————题目：图片上便是一个数塔，现在要解决的问题是，从数塔顶层到底层，沿途将权重（即数值）相加和最大是多少？ 分析：首先再回想一遍动态规划的两个核心。状态分析：我们会发现，当在每个节点都会做一个选择，（例如：在1时，是选择左还是选择右）而选择了左或者右的时候又继续会有选择，我们此时马上就会想到递归（见a）状态转移方程分析：题目要求最大的走法，所以我们可以初步得出一个方程雏形a[选择后的结果]=b[节点]+max(a[左],a[右])现在就需要一点点技巧性了，如何将方程雏形改成真正的状态转移方程此处我们给出一个二维数组的处理办法，如图所示： 即可得出状态转移方程：a[i,j]=b[i,j]+max(a[i+1,j],a[i+1,j+1])理解了题目的状态，得出状态转移方程后，便要考虑计算的问题了 - a -递归计算！！注意边界处理，递归没有什么要讲的，直入代码1234567int dp(int i,int j)&#123; if(i&lt;=n) return b[i,j]+max(dp(i+1,j),dp(i+1,j+1)) if(i&gt;n) return 0;&#125; 例子代码：1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[105][105],m;int dp(int i,int j)&#123; if(i&lt;=m) return a[i][j]+(max(dp(i+1,j),dp(i+1,j+1))); if(i&gt;m) return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; printf("%d",dp(1,1)); &#125; return 0;&#125; 递归算法保证子结构为最优解，所以上一结构也是最优，所以可以得出最大数值路径，但是会产生大量的重复计算，如图片2中会将（3，2）（4，2）（4，3）重复计算两次，如果数塔层数过大，那么效率是很低的，所以孕育而生了递推计算（见b） 记忆化搜索（见c） - b递推计算！！边界处理，递推采用的是一种逆向思维，从数塔最后一层进行处理，比递归计算处理更加的简洁，在大多数情况下（每个决策时间一样），递推法的时间复杂度是：状态总数×每个状态的决策个数×决策时间。 123456789for(int i=1;i&lt;m;i++) b[m][i]=a[m][i];for(int i=m-1;i&gt;=1;i--)&#123; for(int j=1;j&lt;=i;j++) &#123; b[i][j]=a[i][j]+max(b[i+1][j],b[i+1][j+1]); &#125;&#125; 例子代码：123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[105][105];int b[105][105];int m;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; for(int i=1;i&lt;=m;i++) b[m][i]=a[m][i]; for(int i=m-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; b[i][j]=a[i][j]+max(b[i+1][j],b[i+1][j+1]); &#125; &#125; printf("%d",b[1][1]); &#125; return 0;&#125; - c记忆化搜索记忆化搜索是递归的优化版本，利用另一个数组将处理过的数组记录，达到优化目的记录处理：利用memset(b,－1,sizeof(b))将b[ ][ ]数组都初始化为-1，当数组进行过处理直接返回当前数值即可 123456789int dp(int i,int j)&#123; if(b[i][j]&gt;=0) return b[i][j]; if(i&lt;=m) b[i][j]=a[i][j]+max(dp(i+1,j),dp(i+1,j+1)); if(i&gt;m) return 0;&#125; 例子代码和递归没多大差别，就是要注意每次进行需要将数组b[][]进行初始化为-1为下一次计算做准备递归与记忆化搜索的区别 见下图： 图示已将优化体现的很明显了~ 注：1.片段代码或者语言如有错误望谅解并请指出。2.图摘自算法竞赛入门经典第二版，侵权请联系博主删除。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列之和]]></title>
    <url>%2F2017%2F09%2F27%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题简介：求最大连续序列之和。例如：{-1，5，6，-10，15，-9，8}，最大连续子序列和为{5，6，-10，15}，和为16。代码： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn]; //存入序列int b[maxn]; //存储状态 int main() &#123; int m; scanf("%d",&amp;m); for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;a[i]); &#125; //录入样例&#123;-1，5，6，-10，15，-9，8&#125; b[0] = a[0]; int ans = b[0]; for(int i = 1;i&lt;m ; i++) &#123; b[i]=max(a[i],b[i-1]+a[i]); //讲解见a if(ans&lt;b[i]) ans=b[i]; //ans储存最大序列之和 &#125; printf("max %d\n" , ans); for(int i = 0;i&lt;m;i++) //展现状态b[i]每个位置状态 printf("b[%d]=%d\n",i,b[i]); return 0; &#125; a状态转移方程 b[i]=max(a[i],b[i-1]+a[i]) b[i]每个状态为当前序号之前的最大子序列之和，max（）函数将进行选择：1.删除前一状态 a[i] 例如：b[1]=max(a[1],a[1]+b[0]);2.保留前一个状态 b[i-1]+a[i] 例如：b[2]=max(a[2],a[2]+b[1]); 最后用ans将最大的那个状态保存即求出了最大子序列之和]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
