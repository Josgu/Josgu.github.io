<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并查集详解]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[#并查集并查集（Union-find Sets）是一种非常巧妙而且实用的数据结构，主要用于处理一些不想交的集合合并问题。具体包含了两个函数：Union()用来合并和Find()用来查找 以及一个整型数组用来记录每个点的前导点是什么。 ##代码实现 int pre[1050]//记录第i个节点的父亲节点 int Find(int root)//查找根节点 { int son,temp; son=root; while(root != pre[root]){//寻找父亲节点 root = pre[root]; } while(son != root){//路径压缩 temp=pre[son]; pre[son]=root; son=temp; } return son; } void Union(int root1,int root2){//判断是否连通，不连通就合并 int x,y; x=Find(root1); y=Find(root2); if(x!=y)//如果不连通，就把它们所在的连通分支合并 pre[x] = y; } ##算法详解pre[]数组最开始初始化为为pre[i]=i，即表明这pre[i]的父亲节点是i，Union()函数则是将两个节点进行联通，其中Union中用到了Find()函数是找自己的父亲节点判断是否联通，如果不连通就进行pre[x]=y操作，表示为将x节点的父亲节点设置为y。其中Find()函数通过递归判断本节点的上一节点的父亲节点是不是本身，直到找到一个节点的父亲节点是本身的节点作为父亲节点。 在Find()函数中有一个路径压缩算法，是由于Union()函数只是为了连接，所以谁作为父亲节点是随机的，因此最后的树状结构可能很复杂，查找的效率就很低，那么就需要进行路径压缩，让所有的父子节点关系都变成两级结构。 经典例题传送门： HDU 1232畅通工程]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Jos’s blog! This is my first post.]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>hi</tag>
      </tags>
  </entry>
</search>
