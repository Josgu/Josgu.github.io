<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode每天刷day37:2019 力扣杯 有效子数组的数目]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day37_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%9C%89%E6%95%88%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 A，返回满足下面条件的 非空、连续 子数组的数目：子数组中，最左侧的元素不大于其他元素。 提示： 1 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 100000 题目链接:有效子数组的数目C++: 12345678910111213141516class Solution &#123;public: int validSubarrays(vector&lt;int&gt;&amp; nums) &#123; int lens = nums.size(); int cnt = 0; for(int i = 0; i &lt; lens; i++)&#123; for(int j = i; j &lt; lens; j++)&#123; if(nums[j] &gt;= nums[i]) cnt++; else break; &#125; &#125; return cnt; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day37:2019 力扣杯 最长重复子串]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day37_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目:给定字符串 S，找出最长重复子串的长度。如果不存在重复子串就返回 0。提示： 字符串 S 仅包含从 &apos;a&apos; 到 &apos;z&apos; 的小写英文字母。 1 &lt;= S.length &lt;= 1500 题目链接:最长重复子串C++: 123456789101112131415161718192021class Solution &#123;public: int longestRepeatingSubstring(string S) &#123; int lens = S.size(); string maxsubstr; for (int i = 0; i &lt; lens; i++) for (int j = 0; j &lt; i; j++)&#123; string tmp; int k = j; int m = i; while (S[m] == S[k] &amp;&amp; i&lt;lens &amp;&amp; k&lt;lens)&#123; m++; k++; &#125; tmp = S.substr(j, k - j); if (tmp.size()&gt;maxsubstr.size()) maxsubstr = tmp; &#125; return maxsubstr.size(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day37:2019 力扣杯 按字典序排列最小的等效字符串]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day37_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%88%97%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AD%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目: 给出长度相同的两个字符串：A 和 B，其中 A[i] 和 B[i] 是一组等价字符。举个例子，如果 A = “abc” 且 B = “cde”，那么就有 ‘a’ == ‘c’, ‘b’ == ‘d’, ‘c’ == ‘e’。 等价字符遵循任何等价关系的一般规则： 自反性：’a’ == ‘a’ 对称性：’a’ == ‘b’ 则必定有 ‘b’ == ‘a’ 传递性：’a’ == ‘b’ 且 ‘b’ == ‘c’ 就表明 ‘a’ == ‘c’ 例如，A 和 B 的等价信息和之前的例子一样，那么 S = “eed”, “acd” 或 “aab”，这三个字符串都是等价的，而 “aab” 是 S 的按字典序最小的等价字符串 利用 A 和 B 的等价信息，找出并返回 S 的按字典序排列最小的等价字符串。 提示： 字符串 A，B 和 S 仅有从 &apos;a&apos; 到 &apos;z&apos; 的小写英文字母组成。 字符串 A，B 和 S 的长度在 1 到 1000 之间。 字符串 A 和 B 长度相同。 题目链接:按字典序排列最小的等效字符串C++: 123456789101112131415161718192021222324class Solution &#123;public: string smallestEquivalentString(string A, string B, string S) &#123; map&lt;char,char&gt; mp; int lens = A.size(); for(int i = 0; i &lt; lens; i++)&#123; while(mp.count(A[i]) != 0) A[i] = mp[A[i]]; while(mp.count(B[i]) != 0) B[i] = mp[B[i]]; if(A[i] &lt; B[i])&#123; mp.insert(pair&lt;char, char&gt;(B[i], A[i])); &#125; else if(A[i] &gt; B[i])&#123; mp.insert(pair&lt;char, char&gt;(A[i], B[i])); &#125; &#125; for(int i = 0; i &lt; S.size(); i++)&#123; while(mp.count(S[i])) S[i] = mp[S[i]]; &#125; return S; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day37_2019 力扣杯 有序数组中的缺失元素]]></title>
    <url>%2F2019%2F04%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day37_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目:给出一个有序数组 A，数组中的每个数字都是 独一无二的，找出从数组最左边开始的第 K 个缺失数字。 提示： 1 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1e7 1 &lt;= K &lt;= 1e8 题目链接:有序数组中的缺失元素C++: 12345678910111213141516171819202122232425262728class Solution &#123;public: int missingElement(vector&lt;int&gt;&amp; nums, int k) &#123; int lens = nums.size(); if(lens == 1) return nums[0] + k; int tmp = nums[0]; int cnt = 0; int ret; for(int i = 1; i &lt; lens; i++)&#123; if(nums[i] -1 != tmp)&#123; cnt = cnt + nums[i] - tmp - 1; tmp = nums[i]; &#125; else&#123; tmp = nums[i]; &#125; if(cnt &gt;= k)&#123; ret = tmp - cnt + k - 1; break; &#125; if(i == lens - 1)&#123; ret = tmp + k - cnt; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day36:周赛133两地调度]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day36_%E5%91%A8%E8%B5%9B133%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目:公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。 题目链接:两地调度C++:自己写的垃圾代码, 对比比人写的, 感觉自己C++的运用也太垃圾了…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: struct node &#123; int valA; int valB; &#125;; static bool cmp(node a, node b)&#123; if(abs(a.valA - a.valB) == abs(b.valA - b.valB)) return a.valA &gt; b.valA; else return abs(a.valA - a.valB) &gt; abs(b.valA - b.valB); &#125; int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; int ret = 0; int N = costs.size() / 2; vector&lt;node&gt; list; for(int i = 0; i &lt; 2 * N; i++)&#123; node tmp; tmp.valA = costs[i][0]; tmp.valB = costs[i][1]; list.push_back(tmp); &#125; sort(list.begin(), list.end(), cmp); int cntA = N; int cntB = N; for(int i = 0; i &lt; list.size(); i++)&#123; if((cntA &amp;&amp; list[i].valA &lt;= list[i].valB))&#123; ret+= list[i].valA; cntA--; continue; &#125; if((cntB &amp;&amp; list[i].valB &lt;= list[i].valA))&#123; ret+= list[i].valB; cntB--; continue; &#125; while(cntA == 0 &amp;&amp; cntB)&#123; ret+= list[i].valB; cntB--; i++; &#125; while(cntB == 0 &amp;&amp; cntA)&#123; ret+= list[i].valA; cntA--; i++; &#125; &#125; return ret; &#125;&#125;; 贴一个别人的简洁代码, 自己好菜…还是要多读书多看报 123456789101112131415class Solution &#123;public: int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123; sort(costs.begin(),costs.end(),[](vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123; return a[0]-a[1]&lt;b[0]-b[1]; &#125;); int N=costs.size()/2; int r=0; for(int i=0;i&lt;N;i++) r+=costs[i][0]; for(int j=N;j&lt;2*N;j++) r+=costs[j][1]; return r; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day36:周赛133两个非重叠子数组的最大和]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day36_%E5%91%A8%E8%B5%9B133%E4%B8%A4%E4%B8%AA%E9%9D%9E%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目:给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。） 从形式上看，返回最大的 V，而 V = (A[i] + A[i+1] + … + A[i+L-1]) + (A[j] + A[j+1] + … + A[j+M-1]) 并满足下列条件之一： 0 &lt;= i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length, 或 0 &lt;= j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length. 题目链接:两个非重叠子数组的最大和C++:自己纯暴力写的:1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) &#123; int ret = 0; int tmp; for(int i =0; i &lt;= A.size() - L - M; i++)&#123; tmp = 0; for(int k = i; k &lt; i + L; k++) tmp+=A[k]; int tmp2 = tmp; for(int j = i + L; j &lt;= A.size() - M; j++)&#123; for(int z = j; z &lt; j + M; z++)&#123; tmp2 += A[z]; &#125; if(tmp2 &gt; ret)&#123; ret = tmp2; &#125; tmp2 = tmp; &#125; &#125; for(int i =0; i &lt;= A.size() - L - M; i++)&#123; tmp = 0; for(int k = i; k &lt; i + M; k++) tmp+=A[k]; int tmp2 = tmp; for(int j = i + M; j &lt;= A.size() - L; j++)&#123; for(int z = j; z &lt; j + L; z++)&#123; tmp2 += A[z]; &#125; if(tmp2 &gt; ret)&#123; ret = tmp2; &#125; tmp2 = tmp; &#125; &#125; return ret; &#125;&#125;; 方法二:通过数组记录前n项连续子数组和进行求区间和1234567891011121314151617class Solution &#123;public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) &#123; int N=A.size(); vector&lt;int&gt; sums(N+1,0); for(int i=0;i&lt;N;i++) sums[i+1]=A[i]+sums[i]; int r=-1; for(int i=0;i+L&lt;=N;i++)&#123; for(int j=i+L;j+M&lt;=N;j++)&#123; r=max(r,sums[i+L]-sums[i]+sums[j+M]-sums[j]); &#125; for(int j=0;j+M&lt;=i;j++) r=max(r,sums[i+L]-sums[i]+sums[j+M]-sums[j]); &#125; return r; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day36:周赛133距离顺序排列矩阵单元格]]></title>
    <url>%2F2019%2F04%2F21%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day36_%E5%91%A8%E8%B5%9B133%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目:给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。） 提示： 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C 题目链接:距离顺序排列矩阵单元格C++: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: struct node&#123; int x; int y; int dis; &#125;; static bool cmp(node a, node b)&#123; return a.dis &lt; b.dis; &#125; vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123; vector&lt;node&gt; list; vector&lt;vector&lt;int&gt;&gt; ret; for(int i = 0; i &lt; R; i++)&#123; for(int j = 0; j &lt; C; j++)&#123; node tmp; tmp.x = i; tmp.y = j; tmp.dis = abs(i - r0) + abs(j - c0); list.push_back(tmp); &#125; &#125; sort(list.begin(), list.end(), cmp); for(int i =0; i &lt; list.size(); i++)&#123; vector&lt;int&gt; temp; temp.push_back(list[i].x); temp.push_back(list[i].y); ret.push_back(temp); &#125; return ret; &#125;&#125;; 别人的简洁代码: 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123; vector&lt;vector&lt;int&gt;&gt; res; for(int i=0;i&lt;R;i++) for(int j=0;j&lt;C;j++) res.push_back(vector&lt;int&gt;&#123;i,j&#125;); sort(res.begin(),res.end(),[r0,c0](vector&lt;int&gt;&amp;a,vector&lt;int&gt;&amp; b)&#123; return abs(a[0]-r0)+abs(a[1]-c0)&lt;abs(b[0]-r0)+abs(b[1]-c0); &#125;); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day35:Longest Continuous Increasing Subsequence]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day35_Longest%20Continuous%20Increasing%20Subsequence%2F</url>
    <content type="text"><![CDATA[题目:给定一个未经排序的整数数组，找到最长且连续的的递增序列。 题目链接:Longest Continuous Increasing SubsequenceC++: 1234567891011121314151617181920class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0 || nums.size() == 1) return nums.size(); int res = 0; int cnt = 1; for(auto itr1 = nums.begin(), itr2 = nums.begin() + 1; itr2 != nums.end();itr2++)&#123; if(*itr1 &lt; *itr2 &amp;&amp; itr2 != nums.end())&#123; cnt++; &#125; else cnt = 1; if(res &lt; cnt) res = cnt; itr1 = itr2; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day35:Max Area of Island]]></title>
    <url>%2F2019%2F04%2F20%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day35_Max%20Area%20of%20Island%2F</url>
    <content type="text"><![CDATA[题目:给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 题目链接:Max Area of IslandC++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123; int areas = 0, maxAreas = 0; for (int i = 0; i &lt; g.size(); i++) &#123; for (int j = 0; j &lt; g[0].size(); j++) &#123; if (g[i][j] == 1) &#123; areas = dfs(g, i, j); if (areas &gt; maxAreas) maxAreas = areas; &#125; &#125; &#125; return maxAreas; &#125; int dfs(vector&lt;vector&lt;int&gt; &gt; &amp;g, int x, int y) &#123; if (x &gt;= g.size() || y &gt;= g[0].size() || x &lt; 0 || y &lt; 0 || g[x][y] != 1) return 0; else &#123; g[x][y] = -1; return dfs(g, x - 1, y) + dfs(g, x + 1, y) + dfs(g, x, y + 1) + dfs(g, x, y - 1) + 1; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day34:Reverse Words in a String]]></title>
    <url>%2F2019%2F04%2F19%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day34_Reverse%20Words%20in%20a%20String%2F</url>
    <content type="text"><![CDATA[题目:给定一个字符串，逐个翻转字符串中的每个单词 题目链接:Reverse Words in a StringC++: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string reverseWords(string s) &#123; int lens = s.size(); if(lens == 0) return s; stack&lt;string&gt; tmp; bool flag = false; string substr = ""; string res = ""; for(int i = 0; i &lt; lens; i++)&#123; if(s[i] != ' ')&#123; substr = substr + s[i]; flag = true; &#125; if(flag &amp;&amp; (s[i] == ' ' || i == lens - 1))&#123; tmp.push(substr); substr = ""; flag = false; &#125; &#125; if(!tmp.empty())&#123; res = res + tmp.top(); tmp.pop(); &#125; while(!tmp.empty())&#123; res = res + " " + tmp.top(); tmp.pop(); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day33:Combination Sum]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day33_Combination%20Sum%2F</url>
    <content type="text"><![CDATA[题目:给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 题目链接:Combination SumC++:index 可以保证结果不是重复的1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ret; void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; sub, int target, int index) &#123; int sum = 0; for(int i=0;i&lt;sub.size();i++) sum += sub[i]; if(sum==target) &#123; ret.push_back(sub); return; &#125; else if(sum&gt;target) return; else &#123; for(int i=index;i&lt;candidates.size();i++) &#123; sub.push_back(candidates[i]); dfs(candidates, sub, target, i); sub.pop_back(); &#125; &#125; return; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; int len = candidates.size(); if(len == 0) return ret; vector&lt;int&gt; sub; dfs(candidates, sub, target, 0); return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day32: 2019 力扣杯 从始点到终点的所有路径]]></title>
    <url>%2F2019%2F04%2F17%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day32_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E4%BB%8E%E5%A7%8B%E7%82%B9%E5%88%B0%E7%BB%88%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目:给定有向图的边 edges，以及该图的始点 source 和目标终点 destination，确定从始点 source 出发的所有路径是否最终结束于目标终点 destination，即： 从始点 source 到目标终点 destination 存在至少一条路径 如果存在从始点 source 到没有出边的节点的路径，则该节点就是路径终点。 从始点source到目标终点 destination 可能路径数是有限数字 当从始点 source 出发的所有路径都可以到达目标终点 destination 时返回 true，否则返回 false。题目链接:从始点到终点的所有路径C++: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool leadsToDestination(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) &#123; vector&lt;vector&lt;int&gt;&gt; graph(n); bool vis[n]; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; edges.size(); i++)&#123; graph[edges[i][0]].push_back(edges[i][1]); &#125; if(graph[destination].size() != 0) return false; if(n == 1) return true; vis[source] = true; if(!dfs(graph, vis, source, destination)) return false; return true; &#125; bool dfs(vector&lt;vector&lt;int&gt;&gt; &amp;graph, bool *vis, int last, int destination)&#123; if(graph[last].size() == 0) return false; for(int i = 0; i &lt; graph[last].size(); i++)&#123; if(vis[graph[last][i]]) return false; else&#123; if(graph[last][i] == destination)&#123; continue; &#125; vis[graph[last][i]] = true; if(!dfs(graph, vis, graph[last][i], destination)) return false; vis[graph[last][i]] = false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day31: 2019 力扣杯 最小化舍入误差以满足目标]]></title>
    <url>%2F2019%2F04%2F16%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day31_2019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%9C%80%E5%B0%8F%E5%8C%96%E8%88%8D%E5%85%A5%E8%AF%AF%E5%B7%AE%E4%BB%A5%E6%BB%A1%E8%B6%B3%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[题目:给定一系列价格 [p1,p2…,pn] 和一个目标 target，将每个价格 pi 舍入为 Roundi(pi) 以使得舍入数组 [Round1(p1),Round2(p2)…,Roundn(pn)] 之和达到给定的目标值 target。每次舍入操作 Roundi(pi) 可以是向下舍 Floor(pi) 也可以是向上入 Ceil(pi)。 如果舍入数组之和无论如何都无法达到目标值 target，就返回 -1。否则，以保留到小数点后三位的字符串格式返回最小的舍入误差，其定义为 Σ |Roundi(pi) - (pi)|（ i 从 1 到 n ）。 1 &lt;= prices.length &lt;= 500 表示价格的每个字符串 prices[i] 都代表一个介于 0 和 1000 之间的实数，并且正好有 3 个小数位。 target 介于 0 和 1000000 之间。 题目链接:最小化舍入误差以满足目标C++:保留小数返回double类型把我搞懵了, 题目的target没有说是什么类型小声bb123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: static bool cmp(double a, double b)&#123; return a &gt; b; &#125; string minimizeError(vector&lt;string&gt;&amp; prices, int target) &#123; int lens = prices.size(); vector&lt;double&gt; tmp; int minn = 0; int maxn = 0; for(int i = 0; i &lt; lens; i++)&#123; minn += floor(stod(prices[i])); maxn += ceil(stod(prices[i])); tmp.push_back((double)(stod(prices[i]) - floor(stod(prices[i])))); &#125; sort(tmp.begin(), tmp.end(), cmp); if(target &lt; minn || target &gt; maxn) return "-1"; else&#123; auto itr = tmp.begin(); while(target != minn)&#123; minn++; *itr = (1 - *itr); *itr++; &#125; &#125; double via = 0.0; for(int t = 0; t &lt; tmp.size(); t++)&#123; via += tmp[t]; &#125; via = floor(via * 1000.0 + 0.5) /1000.0; string ret = to_string(via); ret = ret.substr(0,ret.size() - 3); return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day28:查看修改文件编码命令]]></title>
    <url>%2F2019%2F04%2F15%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day28_%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[今天从从Windows上拷贝了一个C++源文件,结果出现了中文乱码,在网上看了些查看修改文件编码的命令,以作记录 查看文件编码1.命令file file filename 2.通过vim末行模式输入: :set fileencoding 3.命令行工具enca 没有安装先安装 : sudo apt nstall enca enca [-L LANGUAGE] [OPTION]... [FILE]... enconv [-L LANGUAGE] [OPTION]... [FILE]... 文件编码转换1.通过vim末行模式输入: :set fileencoding=utf-8 2.enconv/enca 转换文件编码，比如要将一个GBK编码的文件转换成UTF-8编码，操作如下 enconv -L zh_CN -x UTF-8 filename enca -L zh_CN -x UTF-8 filename 文件名编码转换使用convmv命令 没有安装先安装convmv sudo apt install convmv convmv -f encoding -t encoding filename //未转换,仅仅可以看到对比 convmv -f encoding -t encoding --notest filename //转换]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day30: 2019 力扣杯 校园自行车分配]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day30_%202019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%A0%A1%E5%9B%AD%E8%87%AA%E8%A1%8C%E8%BD%A6%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目:在由 2D 网格表示的校园里有 n 位工人（worker）和 m 辆自行车（bike），n &lt;= m。所有工人和自行车的位置都用网格上的 2D 坐标表示。我们需要为每位工人分配一辆自行车。在所有可用的自行车和工人中，我们选取彼此之间曼哈顿距离最短的工人自行车对 (worker, bike) ，并将其中的自行车分配給工人。如果有多个 (worker, bike) 对之间的曼哈顿距离相同，那么我们选择工人索引最小的那对。类似地，如果有多种不同的分配方法，则选择自行车索引最小的一对。不断重复这一过程，直到所有工人都分配到自行车为止。给定两点 p1 和 p2 之间的曼哈顿距离为 Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|。返回长度为 n 的向量 ans，其中 a[i] 是第 i 位工人分配到的自行车的索引（从 0 开始）。 题目链接:校园自行车分配C++: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: struct node&#123; int id_worker; int id_bike; int dis; &#125;; static bool cmp(const node &amp;a, const node &amp;b)&#123; if(a.dis == b.dis)&#123; if(a.id_worker == b.id_worker)&#123; return a.id_bike &lt; b.id_bike; &#125; else return a.id_worker &lt; b.id_worker; &#125; else return a.dis &lt; b.dis; &#125; vector&lt;int&gt; assignBikes(vector&lt;vector&lt;int&gt;&gt;&amp; workers, vector&lt;vector&lt;int&gt;&gt;&amp; bikes) &#123; int n = workers.size(); int m = bikes.size(); bool visw[n]; bool visb[m]; vector&lt;int&gt; ret(n); vector&lt;node&gt; tmp; memset(visw, 0, sizeof(visw)); memset(visb, 0, sizeof(visb)); node via; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; via.id_worker = i; via.id_bike = j; via.dis = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1]); tmp.push_back(via); &#125; &#125; sort(tmp.begin(), tmp.end(), cmp); int cnt = 0; for(int i = 0; i &lt; tmp.size(); i++)&#123; if(!visw[tmp[i].id_worker]&amp;&amp;!visb[tmp[i].id_bike])&#123; ret[tmp[i].id_worker] = tmp[i].id_bike; visw[tmp[i].id_worker] = true; visb[tmp[i].id_bike] = true; cnt++; &#125; if(cnt == n) break; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day30: 2019 力扣杯 易混淆数]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day30_%202019%20%E5%8A%9B%E6%89%A3%E6%9D%AF%20%E6%98%93%E6%B7%B7%E6%B7%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目:给定一个数字 N，当它满足以下条件的时候返回 true：把原数字旋转180°以后得到新的数字。如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。2, 3, 4, 5, 7 旋转 180° 后,得到的不是数字。易混淆数字 (confusing number) 就是一个数字旋转180°以后，得到和原来不同的数字，且新数字的每一位都是有效的。 题目链接:易混淆数C++: 123456789101112131415161718192021222324252627class Solution &#123;public: bool confusingNumber(int N) &#123; long cnt = 10; int N_f = 0; map&lt;int,int&gt; m&#123; &#123;0, 0&#125;,&#123;1, 1&#125;,&#123;6, 9&#125;, &#123;8, 8&#125;,&#123;9, 6&#125; &#125;; int temp = 0; int via = N; while(via)&#123; temp = via%10; via /= 10; if(m.count(temp))&#123; N_f = cnt * N_f + m[temp]; &#125; else return false; &#125; if(N == N_f) return false; else return true; &#125;&#125;; :( 没参加,补一下题]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day29:Multiply Strings]]></title>
    <url>%2F2019%2F04%2F13%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day29_Multiply%20Strings%2F</url>
    <content type="text"><![CDATA[题目:给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 题目链接:Multiply Strings C++: 1234567891011121314151617181920212223242526class Solution &#123;public:string multiply(string num1, string num2) &#123; if (num1[0] == '0' || num2[0] == '0') return "0"; int len1 = num1.size(), len2 = num2.size(); int num[len1 + len2] = &#123;0&#125;; for (int i = num1.size() - 1; i &gt;= 0; i--) for (int j = num2.size() - 1; j &gt;= 0; j--) num[i + j + 1] += (num1[i] - '0') * (num2[j] - '0'); int carry = 0; for (int i = len1 + len2 - 1; i &gt;= 0; i--) &#123; num[i] += carry; carry = num[i] / 10; num[i] %= 10; &#125; string ans; int idx = 0; while (idx &lt; len1 + len2 &amp;&amp; num[idx] == 0) idx++; for (; idx &lt; len1 + len2; idx++) ans += num[idx] + '0'; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day27:iostat命令]]></title>
    <url>%2F2019%2F04%2F12%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day27_iostat%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[iostatiostat(I/O statistics)方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等IO设备的活动情况, 负载信息。语法: iostat [OPTION] 选项: -c 显示CPU使用情况 -d 显示磁盘使用情况 -k 以 KB 为单位显示 -m 以 M 为单位显示 -N 显示磁盘阵列(LVM) 信息 -n 显示NFS 使用情况 -p[磁盘] 显示磁盘和分区的情况 -t 显示终端和CPU的信息 -x 显示详细信息 -V 显示版本信息]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day28:Count and Say]]></title>
    <url>%2F2019%2F04%2F12%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day28_Count%20and%20Say%2F</url>
    <content type="text"><![CDATA[题目:报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 “one 1” (“一个一”) , 即 11。11 被读作 “two 1s” (“两个一”）, 即 21。21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 题目链接:Count and Say C++: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: string countAndSay(int n) &#123; if (n == 0) return ""; else if (n == 1) return "1"; else if (n == 2) return "11"; else if (n == 3) return "21"; else if (n == 4) return "1211"; string str = countAndSay(n - 1); string res; char temp = 0; int count = 0; for (char i : str)&#123; if (i != temp) &#123; if (temp != 0) &#123; res += to_string(count) + temp; &#125; temp = i; count = 0; &#125; count++; &#125; if (temp != 0) &#123; res += to_string(count) + temp; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day26:cal命令]]></title>
    <url>%2F2019%2F04%2F11%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day26_%20cal%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[calcal 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份语法: cal [general options] [-jy] [[month] year] cal [general options] [-j] [-m month] [year] ncal -C [general options] [-jy] [[month] year] ncal -C [general options] [-j] [-m month] [year] ncal [general options] [-bhJjpwySM] [-H yyyy-mm-dd] [-s country_code] [[month] year] ncal [general options] [-bhJeoSM] [year] 选项: -y 显示一年 -j 按天数显示 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day27:valid sudoku]]></title>
    <url>%2F2019%2F04%2F11%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day27_valid%20sudoku%2F</url>
    <content type="text"><![CDATA[题目:判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。题目链接:valid sudokuC++: 1234567891011121314151617181920212223class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i = 0; i &lt; 9; i++)&#123; for(int j =0; j &lt; 9; j++)&#123; if(board[i][j] == '.') continue; for(int k = 8; k &gt; j; k--) if(board[i][j] == board[i][k]) return false; for(int k = 8; k &gt; i; k--) if(board[i][j] == board[k][j]) return false; for(int k = i + 1; k % 3 != 0; k ++)&#123; for(int h = j / 3 * 3;h &lt; j / 3 * 3 + 3; h ++ ) if(board[i][j] == board[k][h]) return false; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day27:Search Insert Position]]></title>
    <url>%2F2019%2F04%2F11%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day27_Search%20Insert%20Position%2F</url>
    <content type="text"><![CDATA[题目:给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。题目链接:Search Insert PositionC++:二分查找123456789101112131415161718192021class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if(len == 0) return 0; int l = 0; int r = len -1; int mid = 0; while(l &lt;= r)&#123; mid = (l + r) / 2; if(nums[mid] == target) return mid; if(nums[mid] &lt; target) l = mid +1; else r = mid - 1; &#125; return l; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day26:Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2019%2F04%2F10%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day26_Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[题目:给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。题目链接:Find First and Last Position of Element in Sorted ArrayC++:二分查找,时间复杂度为O(log(n))1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ret(2, -1); int len = nums.size(); if(len &lt;= 0) return ret; int l = 0; int r = len - 1; while(l &lt;= r)&#123; int mid = (r - l) / 2 + l; if(nums[mid] &lt; target)&#123; l = mid + 1; &#125; else&#123; r = mid - 1; &#125; &#125; if(l &gt;= len || nums[l] != target) return ret; ret[0] = l; r = len - 1; while(l &lt;= r)&#123; int mid = (r - l) / 2 + l; if(nums[mid] &gt; target)&#123; r = mid-1; &#125; else&#123; l = mid + 1; &#125; &#125; ret[1] = r; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day25:du命令]]></title>
    <url>%2F2019%2F04%2F09%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day25_du%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dudu (Disk usage) 用来计算每个文件的磁盘用量，目录则取总用量。语法: du [OPTION]... [FILE]... du [OPTION]... --files0-from=F 选项: -a 显示指定目录所有目录以及文件所占的磁盘用量 -h 以可读性较好的方式显示文件大小 -s 只计算命令所指文件所占的总量 -S 计算命令所指文件所有子目录上的文件的大小 和 不包含子目录的占有量 操作:说明:可以发现 -s和-S 让Downloads/目录所占的磁盘空间是不一样的, -S让Downloads/目录计算的是当前目录下所有文件大小,未包含目录,会发现把所有的加起来,两者大小是一样的-a则不仅显示文件也显示目录,同时显示总和]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>du</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day25:Remove Duplicates from Sorted List II]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day25_Remove%20Duplicates%20from%20Sorted%20List%20II%2F</url>
    <content type="text"><![CDATA[题目:给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 题目链接:Remove Duplicates from Sorted List IIC++:1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* ret = new ListNode(0); ret-&gt;next = head; head = ret; ListNode *l; ListNode *r; while(ret-&gt;next)&#123; l = ret-&gt;next; r = l; while(r-&gt;next &amp;&amp; r-&gt;next-&gt;val == l-&gt;val) r = r-&gt;next; if(l == r) ret = ret-&gt;next; else ret-&gt;next = r-&gt;next; &#125; return head-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day25:Search in Rotated Sorted Array]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day25_Search%20in%20Rotated%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[题目:假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 题目链接:Search in Rotated Sorted ArrayC++: 1234567891011121314151617181920212223class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0; int r = nums.size() - 1; while(l &lt;= r)&#123; if(target == nums[l]) return l; if(target == nums[r]) return r; if(target &lt; nums[r])&#123; r--; continue; &#125; if(target &gt; nums[l])&#123; l++; continue; &#125; break; &#125; return -1; &#125;&#125;; 上面一开始写的,好像时间复杂度不是O(log n) 提交16ms 然后优化了一下emmm应该是优化了吧…1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); int l = 0; int r = len - 1; while(l &lt;= r)&#123; if(target == nums[l]) return l; if(target == nums[r]) return r; if(target &lt; nums[r] || target &gt; nums[l])&#123; r--; if(target &lt; nums[l]) l = (l + r)/2; else if(l &gt; 0) l--; continue; &#125; if(target &gt; nums[l] || target &lt; nums[r])&#123; l++; if(target &gt; nums[r]) r = (l + r)/2; else if(r &lt; len -1) r++; continue; &#125; break; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day24:df命令]]></title>
    <url>%2F2019%2F04%2F08%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day24_df%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dfdf (disk free) 其功能显示每个文件所在的文件系统的信息，默认是显示所有文件系统。语法:df [OPTION]… [FILE]选项: -a, --all 显示包括伪，重复，不可访问的文件系统 -B, --block-size=SIZE 缩小尺寸打印; -h, --human-readable 人性化显示 -H, --si print sizes in powers of 1000 (e.g., 1.1G) -i, --inodes 显示iNode信息而非块使用量 -k 即 --block-size=1K -l, --local 只显示本机上的文件系统 --no-sync 取得使用量数据前不进行同步动作(默认) -P, --portability use the POSIX output format --sync invoke sync before getting usage info --total elide all entries insignificant to available space, and produce a grand total -t, --type=TYPE 只显示 TYPE 类型信息 -T, --print-type 显示文件系统的类型 -x, --exclude-type=TYPE 不显示 TYPE 类型信息 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>df</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day24:Longest Valid Parentheses]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day24_Longest%20Valid%20Parentheses%2F</url>
    <content type="text"><![CDATA[题目:给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 题目链接: Longest Valid ParenthesesC++: 1234567891011121314151617181920212223class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; st; int lens = s.size(); int ret = 0; int start = 0; for(int i = 0; i &lt; lens; i++)&#123; if(s[i] == '(') st.push(i); else if(s[i] == ')')&#123; if(st.empty())&#123; start = i + 1; &#125; else&#123; st.pop(); ret = st.empty() ? max(ret , i - start + 1) : max(ret, i-st.top()); &#125; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day23:常用打包解压缩命令]]></title>
    <url>%2F2019%2F04%2F07%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day23_%E5%B8%B8%E7%94%A8%E6%89%93%E5%8C%85%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tar#打包 tar -cvf 打包文件.tar 被打包的文件 #解包 tar -xvf 打包文件.tar gzip可以通过tar 中的 -z选项调用gzip # 压缩文件 tar -zcvf 打包文件.tar.gz 被压缩的文件／路径... # 解压缩文件 tar -zxvf 打包文件.tar.gz # 解压缩到指定路径 tar -zxvf 打包文件.tar.gz -C 目标路径 bzip2可以通过tar 中的 -j选项调用gzip # 压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径... # 解压缩文件 tar -jxvf 打包文件.tar.bz2]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day23:Next Permutation]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day23_Next%20Permutation%2F</url>
    <content type="text"><![CDATA[题目:实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 题目链接:Next PermutationC++:边界判断要注意123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int index = -1; int len = nums.size(); if(len == 0 || len == 1) return ; int tmp = nums[len - 1]; for(int i = len - 2; i &gt;= 0; i--)&#123; if(tmp &lt;= nums[i])&#123; tmp = nums[i]; &#125; else&#123; index = i; break; &#125; &#125; if(index == -1)&#123; sort(nums.begin(), nums.end()); return ; &#125; for(int i = index + 1; i &lt; len; i++)&#123; if(i + 1 == len || nums[i + 1] &lt;= nums[index])&#123; int via = nums[index]; nums[index] = nums[i]; nums[i] = via; sort(nums.begin() + index + 1, nums.end()); break; &#125; &#125; return ; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day22:shutdown命令]]></title>
    <url>%2F2019%2F04%2F06%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day22_shutdown%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[showdownshutdown命令用来进行关机程序,并且关机前传送消息给所有使用者正在执行的程序语法:shutdown [OPTION] [message]选项: -t seconds : 设定在几秒钟之后进行关机程序。 -k : 并不会真的关机，只是将警告讯息传送给所有使用者。 -r : 关机后重新开机。 -h : 关机后停机。 -n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。 -c : 取消目前已经进行中的关机动作。 -f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。 -F : 关机时，强迫进行 fsck 动作。 time : 设定关机的时间。 message : 传送给所有使用者的警告讯息。 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>shutdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim使用简记]]></title>
    <url>%2F2019%2F04%2F06%2Fvim%E4%BD%BF%E7%94%A8%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用了一段时间的vim,还是一种初级阶段,只能日常使用做一些编辑,使用的很僵硬,写一些简记,做些记录,优雅使用vim 再码一遍重新学习加强一下 :) vim模式首先是三种模式: 命令模式 文本输入模式(就相当于记事本啦) 末行模式 三种模式的转换(很懒的随便画一下,凑合看一哈哈哈):设置显示模式 :set showmode关闭显示模式 :set noshowmode显示行号 :set nu隐藏行号 :set nonu vim光标移动光标移动命令：光标上下左右移动命令: ｋ (中指) / [Ctrl] + p 上 ｈ(食指) / [Backspace]左 ｌ (无名指) / [space] 右 ｊ (食指) / [Ctrl] + n 下 对于一个字： w/W 光标向右移动一个字到字首 b/B 光标向左移动一个字到字首 e/E 光标向右移动一个字到字尾 g+e/E 光标向左移动一个字到字尾 对于一行： 0 光标移动到一行行首 $ 光标移动到一行行尾 对于单句的移动： ) 光标移动至句尾 ( 光标移动至句首 对于单个段落： { 光标移动至段落头 } 光标移动至段落尾 对于一屏幕： H 光标移动到屏幕顶行 M 光标移动到屏幕中间行 L 光标移动屏幕３/4行(网上都说是最后一行，当时我自己按是３/４行(＝＠＿＿＠＝)) 对于整个文件 gg 光标移动到文件头 G 光标移动到文件尾 以上命令大多数支持 数字+命令,例如: nj 向上移动ｎ行 ne 向右移动ｎ个字到字尾 ．．． ．．． 以上命令凡是可以处理一个就可以处理多个 vim插入命令普通插入： a 光标后插入 i 光标前插入 o 当前行后开新一行插入 A 当前行尾插入 I 当前行首插入 O 当前行前开新一行插入 替换插入(建议通过尝试理解会更好理解)： r+替换字符 替换光标的字符 R+替换字符串 替换光标后的字符知道按ESC s 删除光标字符，并进入文本输入模式 S 删除光标所在行，并进入文本输入模式 cw 删除当前光标之后所在的一个字，并进入文本输入模式 C 删除当前光标之后所在的一个句子，并进入文本输入模式 以上命令凡是可以处理一个就可以处理多个 vim剪切/复制命令剪切命令:(更喜欢用剪切来说明这个命令，毕竟可粘贴的呀) x/X 剪切光标后/前一个字符 dd 剪切光标当前行 d^ 从光标剪切至行首 d$ 从光标剪切至行尾 dw 从光标剪切至字尾 dl 和x一样 复制命令: yy 复制光标当前行 y^ 从光标复制至行首 y$ 从光标复制至行尾 yw 从光标复制至字尾 yl 和x一样,但是是复制 粘贴命令 p 粘贴 以上命令凡是可以处理一个就可以处理多个 搜索/替换命令搜索命令：在末行模式中使用搜索命令 / + 搜索内容 从光标向文件尾搜索 ? + 搜索内容 从光标向文件头搜索 n 同向重复上一次搜索命令 N 反向重复上一次搜索命令 替换命令： :s/p1/p2/g 直接将光标当前行中所有p1用p2替代,将g换成c每次替换会询问 :n1,n2s/p1/p2/g 直接将光标n1到n2行中所有p1用p2替代,将g换成c每次替换会询问 :g/p1/s//p2/g 直接将文件中所有p1用p2替代,将g换成c每次替换会询问 vim末行模式 末行命令： :x 保存文件并退出 :w 保存文件 :q 退出文件 :q! 退出文件不保存 :!command 执行shell命令command :n1,n2 w!command 将文件中n1到n2行的内容作为command执行 :r!command 将command命令的输出结果放到光标当前行]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day22:Substring with Concatenation of All Words]]></title>
    <url>%2F2019%2F04%2F06%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day22_Substring%20with%20Concatenation%20of%20All%20Words%2F</url>
    <content type="text"><![CDATA[题目:给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 题目链接:Substring with Concatenation of All WordsC++:123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; multiset&lt;string&gt; wordSet; vector&lt;int&gt; ret; int cnt = words.size(); if(cnt == 0 || s.size() == 0) return ret; int aWordLen = words[0].size(); for(auto itr : words)&#123; wordSet.insert(itr); &#125; int len = cnt * aWordLen; for(int i = 0; i &lt; s.size() - len + 1; i++)&#123; string tmp = s.substr(i, len); auto j = wordSet.begin(); while(j != wordSet.end())&#123; int flag = tmp.find(*j); while(flag % aWordLen != 0 &amp;&amp; flag != tmp.npos)&#123; flag = tmp.find(*j, flag + 1); &#125; if(flag != tmp.npos) tmp.erase(flag, aWordLen); else break; j++; &#125; if(tmp.empty()) ret.push_back(i); &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day21:vmstat命令]]></title>
    <url>%2F2019%2F04%2F05%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day21_vmstat%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vmstatvmstat(Virtual Meomory Statistics)用来显示虚拟内存的信息语法: vmstat [options] [delay [count]] 选项: -a：显示活跃和非活跃内存 -f：显示从系统启动至今的fork数量 。 -m：显示slabinfo -n：只在开始时显示一次各字段名称。 -s：显示内存相关统计信息及多种系统活动数量。 -d：显示磁盘相关统计信息。 -p：显示指定磁盘分区统计信息 -w: 按制表格式显示 -S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes） 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux性能监控优化</tag>
        <tag>vmstat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day21:Divide Two Integers]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day21_Divide%20Two%20Integers%2F</url>
    <content type="text"><![CDATA[题目:给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 题目链接:Divide Two IntegersC++:利用位运算实现快速加减1234567891011121314151617181920212223242526272829class Solution &#123;public: int divide(int dividend, int divisor) &#123; long ret = 0; bool flag = false; if((divisor &lt; 0 &amp;&amp; dividend &gt; 0) || (divisor &gt; 0 &amp;&amp; dividend &lt; 0)) &#123; flag = true; &#125; long divisorTmp = fabs(divisor); long dividendTmp = fabs(dividend); if(divisorTmp &gt; dividendTmp) return 0; while(divisorTmp &lt;= dividendTmp)&#123; long cnt = 1, base = divisorTmp; while((base&lt;&lt;1) &lt; dividendTmp)&#123; cnt &lt;&lt;= 1; base &lt;&lt;= 1; &#125; ret += cnt; dividendTmp -= base; &#125; if(flag)&#123; ret = -ret; &#125; return (ret &gt; INT_MAX || ret &lt; INT_MIN) ? INT_MAX : ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day20:free命令]]></title>
    <url>%2F2019%2F04%2F04%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day20_free%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[freefree命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。语法: free [OPTION] 选项: -b 以Byte为单位显示内存使用情况 -k 以KB为单位显示内存使用情况 -m 以MB为单位显示内存使用情况 -g 以GB为单位显示内存使用情况 -o 不显示缓冲区调节列 -s &lt;间隔秒数&gt; 持续观察内存使用状况 -t 显示内存总和列 操作: 字段讲解: total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 shared:多个进程共享的内存总额。 buff/cache:磁盘缓存的大小。 available:可利用的]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux性能监控优化</tag>
        <tag>free</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day20:Remove Element]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day20_Remove%20Element%2F</url>
    <content type="text"><![CDATA[题目:给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 题目链接:Remove Element C++:1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; auto lens = nums.size(); int ret = 0; if(lens == 0) return lens; for(auto f = nums.begin(), t = nums.begin(); t != nums.end(); t++)&#123; if(*t != val)&#123; *f = *t; ret++; f++; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day19:top命令]]></title>
    <url>%2F2019%2F04%2F03%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day19_top%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[toptop命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.语法: top [OPTION] 选项: -d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 -p 通过指定监控进程ID来仅仅监控某个进程的状态。 -q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 -S 指定累计模式 -s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 -i 使top不显示任何闲置或者僵死进程。 -c 显示整个命令行而不只是显示命令名 操作: 字段讲解: 23:12:38 当前时间 up 15:17 系统运行时间，格式为时:分 1 user 当前登录用户数 load average: 0.55, 1.05, 1.47 系统负载. 即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 total 进程总数 running 正在运行的进程数 sleeping 睡眠的进程数 stopped 停止的进程数 zombie 僵尸进程数 Cpu(s): 0.4% us 用户空间占用CPU百分比 1.0% sy 内核空间占用CPU百分比 0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比 96.9% id 空闲CPU百分比 0.0% wa 等待输入输出的CPU时间百分比 0.0%hi：硬件CPU中断占用百分比 0.0%si：软中断占用百分比 0.0%st：虚拟机占用百分比 Mem: 8026648k total 物理内存总量 1127596k free 空闲内存总量 3333728k used 使用的物理内存总量 3565324k buffers 用作内核缓存的内存量 Swap: 2097148k total 交换区总量 2097148k free 空闲交换区总量 0 used 使用的交换区总量 3936728k cached 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚 未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。 汇总: 序号 列名 含义 a PID 进程id b PPID 父进程id c RUSER Real user name d UID 进程所有者的用户id e USER 进程所有者的用户名 f GROUP 进程所有者的组名 g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? h PR 优先级 i NI nice值。负值表示高优先级，正值表示低优先级 j P 最后使用的CPU，仅在多CPU环境下有意义 k %CPU 上次更新到现在的CPU时间占用百分比 l TIME 进程使用的CPU时间总计，单位秒 m TIME+ 进程使用的CPU时间总计，单位1/100秒 n %MEM 进程使用的物理内存百分比 o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA r CODE 可执行代码占用的物理内存大小，单位kb s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb t SHR 共享内存大小，单位kb u nFLT 页面错误次数 v nDRT 最后一次写入到现在，被修改过的页面数。 w S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程) x COMMAND 命令名/命令行 y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 z Flags 任务标志，参考 sched.h]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux性能监控优化</tag>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day19:Reverse Nodes in k-Group]]></title>
    <url>%2F2019%2F04%2F03%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day19_Reverse%20Nodes%20in%20k-Group%2F</url>
    <content type="text"><![CDATA[题目:给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 题目链接:Reverse Nodes in k-GroupC++:分段反转链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverse(ListNode* head, int k) &#123; ListNode *f = head-&gt;next; ListNode *s = nullptr; ListNode *r = nullptr; int len = 0; while(f) &#123; len++; f = f-&gt;next; &#125; if(len &lt; k) return head; f = head-&gt;next; while(f &amp;&amp; k--) &#123; s = f-&gt;next; f-&gt;next = r; r = f; f = s; &#125; head-&gt;next = r; f = head; while(f-&gt;next) f = f-&gt;next; f-&gt;next = s; return head; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k == 0 || k == 1)&#123; return head; &#125; ListNode* ret = new ListNode(0); ListNode* retHead = ret; ret-&gt;next = head; while(retHead)&#123; reverse(retHead, k); for(int i = 0; i &lt; k; i++)&#123; retHead = retHead-&gt;next; if(retHead == nullptr) break; &#125; &#125; return ret-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day18:chown命令]]></title>
    <url>%2F2019%2F04%2F02%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day18_chown%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[chownchown(Change owner) 用来改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户ID，用户组可以是组名或组ID。只有文件主和超级用户才可以便用该命令。 语法: chown [OPTION]... [OWNER][:[GROUP]] FILE... or: chown [OPTION]... --reference=RFILE FILE... 选项: -c --changes 类似于 --verbose,但只在更改时才会显示结果 -f 去除大部分的错误信息 -R 递归处理所有文件及其子目录 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day18:Remove Duplicates from Sorted Array]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day18_Remove%20Duplicates%20from%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[题目:给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 题目链接:Remove Duplicates from Sorted ArrayC++:双指针1234567891011121314151617class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int lens = nums.size(); if(lens == 0 || lens == 1) return lens; int ret = 1; for(auto itr1 = nums.begin(), itr2 = nums.begin() + 1; itr2 != nums.end(); itr2++)&#123; if(*itr1 != *itr2)&#123; *(itr1 + 1) = *itr2; itr1++; ret++; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天盘活个人博客]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%BB%8A%E5%A4%A9%E7%9B%98%E6%B4%BB%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天将csdn上的博客全部搬到这里啦~ 以后两边都更新,请大家多多指教哈哈!]]></content>
      <categories>
        <category>简记</category>
      </categories>
      <tags>
        <tag>Hi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day17:chgrp命令]]></title>
    <url>%2F2019%2F04%2F01%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day14_chgrp%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[chgrpchgrp(Change group) 用来将每个指定文件的所属组设置为指定值。如果使用 –reference，则将每个文件的所属组设置为与指定参考文件相同。语法: chgrp [OPTION]... GROUP FILE... or:chgrp [OPTION]... --reference=RFILE FILE... 选项: -c --changes 类似于 --verbose,但只在更改时才会显示结果 -f 去除大部分的错误信息 -R 递归处理所有文件及其子目录 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件权限管理</tag>
        <tag>chgrp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day17:Merge k Sorted Lists]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day14_Merge%20k%20Sorted%20Lists%2F</url>
    <content type="text"><![CDATA[题目:合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 题目链接:Merge k Sorted ListsC++:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1!=NULL || l2!=NULL)&#123; if(l1&amp;&amp;l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; while(l1!=NULL &amp;&amp; l2==NULL)&#123; head-&gt;next = l1; head = head-&gt;next; l1 = l1-&gt;next; &#125; while(l1==NULL &amp;&amp; l2!=NULL)&#123; head-&gt;next = l2; head = head-&gt;next; l2 = l2-&gt;next; &#125; &#125; return res-&gt;next; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if(lists.empty())&#123; return NULL; &#125; if(lists.size() == 1)&#123; return lists[0]; &#125; else if(lists.size() == 2)&#123; return mergeTwoLists(lists[0], lists[1]); &#125; int mid = lists.size()/2; vector&lt;ListNode*&gt; l1,l2; for(int i = 0; i &lt; mid; i++) l1.push_back(lists[i]); for(int i = mid; i &lt; lists.size(); i++) l2.push_back(lists[i]); ListNode *L1 = mergeKLists(l1); ListNode *L2 = mergeKLists(l2); return mergeTwoLists(L1, L2); &#125;&#125;; 合并排序,分治思想运用]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day17:Swap Nodes in Pairs]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day14_Swap%20Nodes%20in%20Pairs%2F</url>
    <content type="text"><![CDATA[题目:给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 题目链接:Swap Nodes in PairsC++:绕1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *p, *q; ListNode *ret = new ListNode(0); ret-&gt;next = head; q = ret; while(head != nullptr &amp;&amp; head-&gt;next != nullptr)&#123; p = head-&gt;next; head-&gt;next = p-&gt;next; p-&gt;next = head; q-&gt;next = p; q = head; head = head-&gt;next; &#125; return ret-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day16:chmod命令]]></title>
    <url>%2F2019%2F03%2F30%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day13_chmod%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[chmodchmod(Change mode) 用来将每个文件的模式更改为指定值。语法: chmod [OPTION]... MODE[,MODE]... FILE... or: chmod [OPTION]... OCTAL-MODE FILE... or: chmod [OPTION]... --reference=RFILE FILE... 选项: -c, --changes 类似 --verbose，但只在有更改时才显示结果 -f, --silent, --quiet 去除大部份的错误信息 -v, --verbose 为处理的所有文件显示诊断信息 -R, --recursive 以递归方式更改所有的文件及子目录 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件权限管理</tag>
        <tag>chmod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day16:Generate Parentheses]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day13_Generate%20Parentheses%2F</url>
    <content type="text"><![CDATA[题目:给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 题目链接:Generate Parentheses C++:递归1234567891011121314151617181920212223class Solution &#123;vector&lt;string&gt; res; public: void generate(string str, int left, int right) &#123; if(left &lt;= 0) &#123; for(int i=0;i&lt;right;i++) str.push_back(')'); res.push_back(str); &#125; else &#123; if(left &lt; right) generate(str+')', left, right-1); generate(str+'(', left-1, right); &#125; &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; generate("", n, n); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day15:find命令]]></title>
    <url>%2F2019%2F03%2F29%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day12_find%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[find find(find) 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。语法: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression] 选项: &apos;-H&apos;表示只跟随命令行中指定的符号连接， &apos;-L&apos;表示跟随所有的符号连接， &apos;-P&apos;是默认的选项，表示不跟随符号连接。 -D debugoptions. 打印诊断信息 -Olevel Enables query optimisation. 允许查询优化 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>find</tag>
        <tag>Linux文件查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day15:Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F03%2F29%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day13_Merge%20Two%20Sorted%20Lists%2F</url>
    <content type="text"><![CDATA[题目:将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 题目链接:Merge Two Sorted ListsC++:链表归并操作123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* res = new ListNode(0); ListNode* head = res; while(l1!=NULL || l2!=NULL)&#123; if(l1&amp;&amp;l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; head-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; head-&gt;next = l2; l2 = l2-&gt;next; &#125; head = head-&gt;next; &#125; while(l1!=NULL &amp;&amp; l2==NULL)&#123; head-&gt;next = l1; head = head-&gt;next; l1 = l1-&gt;next; &#125; while(l1==NULL &amp;&amp; l2!=NULL)&#123; head-&gt;next = l2; head = head-&gt;next; l2 = l2-&gt;next; &#125; &#125; return res-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>归并</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day15:which命令]]></title>
    <url>%2F2019%2F03%2F28%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day12_which%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[whichwhich (which) 命令的作用是在PATH变量指定的路径中搜索某个系统命令的位置并且返回第一个搜索结果。也就是说使用which命令就可以看到某个系统命令是否存在以及执行的到底是哪一个位置的命令语法: which [-a] filename ... 选项: -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p 与-n参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。 -V 显示版本信息 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件查找</tag>
        <tag>which</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day14:Valid Parentheses]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day12_Valid%20Parentheses%2F</url>
    <content type="text"><![CDATA[题目:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 题目链接:Valid ParenthesesC++:123456789101112131415161718192021222324class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; st; int lens = s.size(); for(int i = 0; i &lt; lens; i++)&#123; if(s[i] == ')' || s[i] == ']' || s[i] == '&#125;') &#123; if(st.size() == 0) return false; if(st.top() == '(' &amp;&amp; s[i] != ')') return false; if(st.top() == '[' &amp;&amp; s[i] != ']') return false; if(st.top() == '&#123;' &amp;&amp; s[i] != '&#125;') return false; st.pop(); &#125; else st.push(s[i]); &#125; return st.size() == 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day14:Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F03%2F28%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day12_Remove%20Nth%20Node%20From%20End%20of%20List%2F</url>
    <content type="text"><![CDATA[题目:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。说明：给定的 n 保证是有效的。进阶：你能尝试使用一趟扫描实现吗？ 题目链接:Remove Nth Node From End of ListC++:自己的思路是这样写的，但是编码的太丑了，挂上别人简洁的代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *p = head, *q = head; while(n--)&#123; q=q-&gt;next; &#125; if(!q) &#123; return head-&gt;next; &#125; while(q-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next; &#125; p-&gt;next = p-&gt;next-&gt;next; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day13:head命令]]></title>
    <url>%2F2019%2F03%2F27%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day11_head%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[headhead (head) 用来显示档案的开头至标准输出中。如果指定了多于一个文件，在每一段输出前会给出文件名作为文件头。如果不指定文件，或者文件为”-“，则从标准输入读取数据。语法: head [OPTION]... [FILE]... 选项: -c, --bytes=[-]K 显示每个文件的前K 字节内容；如果附加&quot;-&quot;参数，则除了每个文件的最后K字节数据外 显示剩余全部内容 -n, --lines=[-]K 显示每个文件的前K 行内容；如果附加&quot;-&quot;参数，则除了每个文件的最后K行外 显示剩余全部内容 -q, --quiet, --silent 不显示包含给定文件名的文件头 -v, --verbose 总是显示包含给定文件名的文件头 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>head</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day13:4Sum]]></title>
    <url>%2F2019%2F03%2F27%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day12_4Sum%2F</url>
    <content type="text"><![CDATA[题目链接:4SumC++: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; for(int i = 0; i &lt; len - 2; i++)&#123; if(i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; int temp = target - nums[i]; for(int j = i + 1; j &lt; len - 1; j++)&#123; if(j != i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; int temp2 = temp - nums[j]; int st = j + 1; int en = len -1; while(st &lt; en)&#123; //cout&lt;&lt;nums[i]&lt;&lt;nums[j]&lt;&lt;nums[st]&lt;&lt;nums[en]&lt;&lt;endl; if(nums[st] + nums[en] == temp2) &#123; vector&lt;int&gt; tmp = &#123;nums[i], nums[j], nums[st], nums[en]&#125;; ans.push_back(tmp); st++; while(st &lt; len - 1 &amp;&amp; nums[st] == nums[st-1]) st++; &#125; else if(nums[st] + nums[en] &lt; temp2) st++; else en--; &#125; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:二叉树的建立与线索二叉树]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树的建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*按前序输入二叉树结点中的值(一个字符)*//*#表示空结点,构造二叉链表表示二叉树T*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef char ElemType;//结点数据结构typedef struct BiTNode&#123; ElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;//生成二叉树void CreateBiTree(BiTree *T)&#123; char c; scanf("%c", &amp;c); if('#' == c)&#123; *T = NULL; &#125; else &#123; *T = (BiTNode *)malloc(sizeof(BiTNode)); (*T)-&gt;data = c; //根 CreateBiTree(&amp;(*T)-&gt;lchild); //左 CreateBiTree(&amp;(*T)-&gt;rchild); //右 &#125;&#125;//输出当前层的数据void visit(char c,int level)&#123; printf("%c 位于第 %d 层\n", c, level);&#125;//前序遍历输出树void PreOrderTraverse(BiTree T, int level)&#123; if(T)&#123; visit(T-&gt;data,level); PreOrderTraverse(T-&gt;lchild, level + 1); PreOrderTraverse(T-&gt;rchild, level + 1); &#125;&#125;int main()&#123; int level = 1; BiTree T = NULL; CreateBiTree(&amp;T); PreOrderTraverse(T, level); return 0;&#125; 通过中序遍历(后序遍历)的字符串可同理操作; #### 线索二叉树为什么需要线索二叉树？1.由于在二叉链表中，我们只知道每一个结点的左右孩子结点的地址，而不知道结点的前驱和后继是谁，所以需要知道前驱和后继就必须遍历一遍2.一颗二叉树中，每个结点都有两个指针域，共2n个指针域, 在n个结点的二叉树中有n-1条分支线数, 也就是说其实有n+1个空指针域.造成了相当大的内存浪费.线索二叉树的原理：将存储结构为二叉链表的二叉树的叶子结点的空指针域进行利用，将其作为线索指向前驱后继 简单理解:线索二叉树其实就是双向链表,对二叉树以某种次序遍历使其变成线索二叉树 如何知道某一节点的lchild(rchild)是指向孩子结点还是指向前驱(后继)呢? 在结点的结构中,添加两个标记变量LTag 和 RTag进行标记,指向孩子结点时候为0,指向前驱后继为1. 线索二叉树结构实现: 1234567891011121314151617181920212223242526272829typedef char ElemType;typedef enum &#123;Link, Thread&#125; PointerTag;typedef struct BiThrNode&#123; ElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag; PointerTag RTag;&#125;BiThrNode, *BiThrTree;BiThrTree pre;//始终指向刚刚被访问过的结点//中序线索化void InThreading(BiThrTree p)&#123; if(p) &#123; InThreading(p-&gt;lchild);//递归线索化左子树 if(!p-&gt;lchild)&#123; p-&gt;LTag = Thread; p-&gt;lchild = pre;//左孩子指针指向前驱 &#125; if(!pre-&gt;rchild)&#123; pre-&gt;RTag = Thread; pre-&gt;rchild = p;//前驱右孩子指针指向后继(当前结点p) &#125; pre = p;//保持pre指向p的前驱 InThreading(p-&gt;rchild);//递归线索化右子树 &#125;&#125; 中序线索化遍历 12345678910111213141516void InOrderTraverse_Thr(BiThrTree T)&#123; BiThrTree p; p = T -&gt;lchild; while(p != T) &#123; while(p-&gt;LTag == Link) p = p-&gt;lchild; printf("%c", p-&gt;data); while(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)&#123; p = p-&gt;rchild; printf("%c",p-&gt;data); &#125; p = p-&gt;rchild; &#125; return;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day12:less命令]]></title>
    <url>%2F2019%2F03%2F26%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day11_less%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[lessless(less) 命令可以对文件或其它输出进行分页显示，与moe命令相似，但是比more命令要强大许多。 语法: less [options] &lt;file&gt;... 选项: -b &lt;缓冲区大小&gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &lt;数字&gt; 将&quot;tab&quot;键显示为规定的数字空格 查看操作: /字符串：向下搜索&quot;字符串&quot;的功能 ?字符串：向上搜索&quot;字符串&quot;的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一页 回车键 滚动一行 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day12:Letter Combinations of a Phone Number]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day12_Letter%20Combinations%20of%20a%20Phone%20Number%2F</url>
    <content type="text"><![CDATA[题目:给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 题目链接:Letter Combinations of a Phone NumberC++:12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; unordered_map&lt;char, string&gt; table&#123; &#123;'2', "abc"&#125;,&#123;'3',"def"&#125;, &#123;'4',"ghi"&#125;, &#123;'5',"jkl"&#125;,&#123;'6',"mno"&#125;, &#123;'7',"pqrs"&#125;, &#123;'8',"tuv"&#125;,&#123;'9',"wxyz"&#125; &#125;; vector&lt;string&gt; res; if(digits == "") return res; fun(res, "", digits, table, 0); return res; &#125; void fun(vector&lt;string&gt; &amp;res, string str, string &amp;digits, unordered_map&lt;char, string&gt; &amp;m, int k)&#123; if(str.size() == digits.size())&#123; res.push_back(str); return; &#125; string tmp = m[digits[k]]; for(char w : tmp)&#123; str += w; fun(res, str, digits, m, k+1); str.pop_back(); &#125; return ; &#125;&#125;; 排列组合,利用递归求解]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day11:more命令]]></title>
    <url>%2F2019%2F03%2F25%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day11_more%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[moremore (more) 该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比,方便逐页阅读(file perusal filter for crt viewing) 。more名单中内置了若干快捷键，按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中按h可以查看说明文件 。语法: more [options] &lt;file&gt;... 选项: -num 一次显示的行数 -d 提示使用者，在画面下方显示 [Press space to continue, &apos;q&apos; to quit.] 如果按错键，则会显示 [Press &apos;h&apos; for instructions.] 而不是 &apos;哔&apos; 声 -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能 忽略Ctrl+l（换页）字符 -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上） -p 清屏显示 -s 当遇到有连续两行以上的空白行，就代换为一行的空白行 +/ 在每个档案显示前搜寻该字串（pattern），然后从该字串之后开始显示 +num 从第 num 行开始显示 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>more</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day11:3Sum Closest]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day11_3Sum%20Closest%2F</url>
    <content type="text"><![CDATA[题目:给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 题目链接:3Sum ClosestC++:123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if(len &lt; 3) return 0; if(len == 3) return nums[0] + nums[1] + nums[2]; sort(nums.begin(), nums.end()); int sum3 = 0, min3 = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; len - 1; i++)&#123; if(i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; int j = i + 1; int k = len - 1; while(j &lt; k)&#123; //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;k&lt;&lt;endl; sum3 = nums[i] + nums[j] + nums[k]; if(abs(target - sum3) &lt; abs(target - min3))&#123; min3 = sum3; while(j &lt; k -1 &amp;&amp; nums[j] == nums[j+1]) j++; &#125; else if(target &gt; sum3) j++; else if(target &lt; sum3) k--; else return target; while(k &gt; j + 1 &amp;&amp; nums[k] == nums[k-1]) k--; &#125; &#125; return min3; &#125;&#125;; 任然运用的是双指针，其中蕴含着分而治之的思想．]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day11:3Sum]]></title>
    <url>%2F2019%2F03%2F25%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day11_3Sum%2F</url>
    <content type="text"><![CDATA[题目:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 题目链接:3Sum C++ 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; for(int i = 0;i &lt; len;++i)&#123; if(i != 0 &amp;&amp; nums[i] == nums[i-1]) continue; int j = (i+1 &lt; len) ? i+1 : len-1; int k = len-1; while(j &lt; k)&#123; if(nums[j] + nums[k] == -(nums[i]))&#123; vector&lt;int&gt; tmp = &#123;nums[i],nums[j],nums[k]&#125;; ans.push_back(tmp); j++; while(j &lt; len-1 &amp;&amp; nums[j] == nums[j-1]) j++; &#125; else if(nums[j] + nums[k] &lt; -(nums[i]))&#123; j++; &#125; else&#123; k--; &#125; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:递归]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归简单理解：对函数自身反复调用当问题是重复的子问题，递归可以很好的实现简例：斐波那契数列的迭代实现F(0)=0，F(1)=1斐波那契数列F(n)=F(n-1)+F(n-2) (n&gt;1)遍历：123456789101112#include&lt;stdio.h&gt;int main()&#123; int fib[40]; fib[0] = 0; fib[1] = 1; for(int i=2; i &lt; 40; i++) &#123; a[i] = a[i-1] + a[i-2]; printf("%d\n" , a[i]); &#125; return 0&#125; 递归： 12345int Fib(int n)&#123; if( n &lt; 2) return i == 0 ? 0 : 1; return Fib(i-1) + Fib(i-2);&#125; 简例：汉诺塔问题三个柱子，A、B、C 12345678910void move(int n , char A, char B , char C)&#123; if（n == 1)&#123; printf("%c-----&gt;%c" , A , B); &#125; else&#123; move (n-1,A , B , C); printf("%c-----&gt;%c" , A , C); move (n-1, B, A, C); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day10:nl命令]]></title>
    <url>%2F2019%2F03%2F24%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day10_nl%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[nlnl (Number of Lines) 将指定的文件添加行号标注后写到标准输出。如果不指定文件或指定文件为”-“ ，程序将从标准输入读取数据。语法: nl [OPTION]... [FILE]... 选项: -b, --body-numbering=样式 使用指定样式编号文件的正文行目 -d, --section-delimiter=CC 使用指定的CC 分割逻辑页数 -f, --footer-numbering=样式 使用指定样式编号文件的页脚行目 -h, --header-numbering=样式 使用指定样式编号文件的页眉行目 -i, --page-increment=数值 设置每一行遍历后的自动递增值 -l, --join-blank-lines=数值 设置数值为多少的若干空行被视作一行 -n, --number-format= 格式 根据指定格式插入行号 -p, 在逻辑页数切换时不将行号值复位 -s, --number-separator=字符串 可能的话在行号后添加字符串 -v, --starting-line-number=数字 每个逻辑页上的第一行的行号 -w, --number-width= 数字 为行号使用指定的栏数 a 对所有行编号 t 对非空行编号 n 不编行号 pBRE 只对符合正则表达式BRE 的行编号 FORMAT 是下列之一: ln 左对齐，空格不用0 填充 rn 右对齐，空格不用0 填充 rz 右对齐，空格用0 填充 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>nl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day10:Longest Common Prefix]]></title>
    <url>%2F2019%2F03%2F24%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day10_Longest%20Common%20Prefix%2F</url>
    <content type="text"><![CDATA[题目:编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 题目链接:Longest Common PrefixC++ 12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; int lens = strs.size(); if(lens==0) return ""; string ans=strs[0]; for(int i=1;i&lt;lens;i++) &#123; int j=0,len=min(ans.size(),strs[i].size()); while(j&lt;len &amp;&amp; ans[j]==strs[i][j]) j++; ans.erase(ans.begin()+j,ans.end()); if(ans=="") break; &#125; return ans; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day10:Roman to Integer]]></title>
    <url>%2F2019%2F03%2F24%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day10%3BRoman%20to%20Integer%2F</url>
    <content type="text"><![CDATA[罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 题目链接:Roman to Integer C++:12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; int res = 0; unordered_map&lt;char, int&gt; m&#123;&#123;'I', 1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int lens = s.size(); for (int i = 0; i &lt; lens; i++) &#123; int val = m[s[i]]; if (i == lens - 1 || m[s[i+1]] &lt;= m[s[i]]) res += val; else res -= val; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day9:tail命令]]></title>
    <url>%2F2019%2F03%2F23%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day9_tail%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tailtail (tail) 用来显示档案的结尾(默认为10行)至标准输出中。若指定了多于一个文件，程序会在每段输出的开始添加相应文件名作为头。如果不指定文件或文件为”-“ ，则从标准输入读取数据。 语法:\ tail [OPTION]... [FILE]... 选项: -c, --bytes=K 输出最后K字节；另外，使用-c +K 从每个文件的第K 字节输出 -f,即时输出文件变化后追加的数据。 -n,输出最后K行；另外，使用-n +K 从每个文件的第K行输出 -s, 与-f合用,表示在每次反复的间隔休眠N秒 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>tail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day9:Integer to Roman]]></title>
    <url>%2F2019%2F03%2F23%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day9_Integer%20to%20Roman%2F</url>
    <content type="text"><![CDATA[题目:罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。题目链接:Integer to Roman C++12345678910111213141516class Solution &#123;public: string intToRoman(int num) &#123; int values[]=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; string reps[]=&#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; string ret; for(int i=0; i&lt;13; i++)&#123; while(num&gt;=values[i])&#123; num -= values[i]; ret += reps[i]; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day8:cat/tac命令]]></title>
    <url>%2F2019%2F03%2F22%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day8_cat_tac%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cat(tac反向操作)cat (concatenate)命令将[文件]或标准输入组合输出到标准输出，如果没有指定文件，或者文件为”-“，则从标准输入读取。语法: cat [OPTION]... [FILE]... 选项: -A, --show-all 等于-vET -b, --number-nonblank 对非空输出行编号 -e,等于-vE -E, --show-ends 在每行结束处显示&quot;$&quot; -n, --number 对所有行编号，包括空行 -s, --squeeze-blank 压缩多行空行为一空行 -t ,与-vT 等价 -T, --show-tabs 将跳格(TAB)字符显示为^I -v, --show-nonprinting 使用^ 和M- 引用，除了LFD和 TAB 之外 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文本内容查看</tag>
        <tag>cat</tag>
        <tag>tac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day8:rm命令]]></title>
    <url>%2F2019%2F03%2F22%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day8_rm%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rm语法: rm [OPTION]... [FILE]... 选项: -f, –force强制删除。忽略不存在的文件，不提示确认 -i,在删除前需要确认 -r, -R, --recursive 递归删除目录及其内容 -v, –verbose 详细显示进行的步骤 -d,删除空的目录 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>rm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day8:Palindrome Number]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day8_Palindrome%20Number%2F</url>
    <content type="text"><![CDATA[题目:判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 题目链接:Palindrome NumberC++: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || (x%10==0 &amp;&amp; x!=0)) return false; if(x&gt;=0 &amp;&amp; x &lt; 10) return true; long m = 0 ,n = x; while(n)&#123; m = m * 10 + n % 10; n /= 10; &#125; if(m == x) return true; else return false; &#125;&#125;;//不解leetcode上为什么下面跑的没有上面快?class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || (x % 10 ==0 &amp;&amp; x != 0)) return false; if(x&gt;=0 &amp;&amp; x &lt; 10) return true; int m = 0; while(x &gt; m)&#123; m = m * 10 + x % 10; x /= 10; &#125; if (m == x || m / 10 == x) return true; else return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day8:Container With Most Water]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day8_Container%20With%20Most%20Water%2F</url>
    <content type="text"><![CDATA[题目:给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 题目链接:Container With Most Water C++双索引12345678910111213141516171819202122class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i = 0; int j = height.size()-1; int maxArea = -1; while(i!=j)&#123; if(height[i] &gt; height[j]) &#123; if(maxArea &lt; height[j]*(j - i)) maxArea = height[j]*(j - i); j--; &#125; else&#123; if(maxArea &lt; height[i]*(j - i)) maxArea = height[i]*(j - i); i++; &#125; &#125; return maxArea; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu18.04安装WPS]]></title>
    <url>%2F2019%2F03%2F21%2FUbuntu18.04%E5%AE%89%E8%A3%85WPS%2F</url>
    <content type="text"><![CDATA[大家都蛮喜欢折腾Ubuntu的,所以再回头给大家记一个安装WPS的教程先看效果 还是很不错哒!!步骤 下载两个安装包:安装包和字体 sudo dpkg -i 包名(按你下的包名来哈) 其实这个时候已经安装好了,找到WPS的图标点开会弹出一个系统错误,提示缺少系统字体.由于我已经安好了(捂脸)错误已经解决了,所以就没截图了 解决办法:链接: https://pan.baidu.com/s/18wWiTtTPL65_lXwoiAkCMQ 提取码: xcqm下载字体文件 然后在加载的目录启动终端 sudo unzip wps_symbol_fonts.zip -d /usr/share/fonts/wps-office 然后重启wps就可以啦 再补两张效果图:]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu wps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day7:mv命令]]></title>
    <url>%2F2019%2F03%2F21%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day7_mv%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mvmv（Move file）将源文件重命名为目标文件，或将源文件移动至指定目录 语法: mv [OPTION]... [-T] SOURCE DEST or: mv [OPTION]... SOURCE... DIRECTORY or: mv [OPTION]... -t DIRECTORY SOURCE... 选项: -b,若移动文件会覆盖,会自动对覆盖文件进行备份 -f,覆盖前不询问 -i, 覆盖前询问 -n,不覆盖已存在文件 如果您指定了-i、-f、-n 中的多个，仅最后一个生效。 --strip-trailing-slashes 去掉每个源文件参数尾部的斜线 -S,替换常用的备份文件后缀 -t,将所有参数指定的源文件或目录 移动至 指定目录 -T,将目标文件视作普通文件处理 -u,只在源文件文件比目标文件新，或目标文件不存在时才进行移动 -v,详细显示进行的步骤 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>mv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day7:String to Integer (atoi)]]></title>
    <url>%2F2019%2F03%2F21%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day7_String%20to%20Integer%20(atoi)%2F</url>
    <content type="text"><![CDATA[题目:请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 题目链接:String to Integer (atoi)C++:12345678910111213141516171819202122232425262728class Solution &#123;public: int myAtoi(string str) &#123; long ret = 0; int plmi = 1; int lens = str.size(); long long i; for(i = 0; i &lt; lens;)&#123; i = str.find_first_not_of(' '); if(i != string::npos)&#123; if(str[i] == '+' || str[i] == '-') &#123; plmi = (str[i++] == '+') ? 1 : -1; &#125; while(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; ret = ret*10 + (str[i++] - '0'); if(plmi*ret &gt;= INT_MAX || plmi*ret &lt;= INT_MIN) return plmi*ret &gt;= INT_MAX ? INT_MAX : INT_MIN; &#125; return plmi*ret; &#125; else return 0; &#125; return 0; &#125;&#125;; string类中自带函数find_not_first_of()等查找函数若未找到相应元素返回string::npos]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day7:Reverse Integer]]></title>
    <url>%2F2019%2F03%2F21%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day7_Reverse%20Integer%2F</url>
    <content type="text"><![CDATA[题目:给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 题目链接:Reverse IntegerC++12345678910111213141516171819class Solution &#123;public: int reverse(int x) &#123; long long ret = 0; int carry = 10; while(x)&#123; ret = ret + x%10; x /= 10; if(x)&#123; ret *= carry; if(ret &gt; 2147483647 || ret &lt; -2147483648) &#123; return 0; &#125; &#125; &#125; return (int)ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数字反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day6:cp命令]]></title>
    <url>%2F2019%2F03%2F20%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day6_cp%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cpcp（Copy file）：将源文件复制至目标文件，或将多个源文件复制至目标目录。 语法: cp [OPTION]... [-T] SOURCE DEST or: cp [OPTION]... SOURCE... DIRECTORY or: cp [OPTION]... -t DIRECTORY SOURCE... 选项: -a, 用于复制整个目录，包括目录中的子目录等都递归的复制，而且还要保持文件的访问模式，所有者，时间戳等属性与原文件一样。 -f, 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项) -i, 覆盖前询问(使前面的 -n 选项失效),默认cp命令覆盖目标文件时是不会提示的 -l, 对源文件建立硬链接，而非复制文件 -n,不要覆盖已存在的文件(使前面的 -i 选项失效) -p 保持指定的属性(默认：模式,所有权,时间戳) -R, -r, 递归复制目录及其子目录内的所有内容 -s, 只创建符号链接而不复制文件 -t, 将所有参数指定的源文件/目录 复制至目标目录 -u, 使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； -v, 详细显示命令执行的操作。 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>cp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day6:ZigZag Conversion]]></title>
    <url>%2F2019%2F03%2F20%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day6_ZigZag%20Conversion%2F</url>
    <content type="text"><![CDATA[题目:将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 题目链接：ZigZag Conversion C++： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string convert(string s, int numRows) &#123; vector&lt;string&gt; row(numRows); int lens = s.size(); int r = 0; bool flag = true; if(numRows == 1) return s; for(int i = 0; i &lt; lens; i++)&#123; row[r].push_back(s[i]); if(flag)&#123; r++; &#125; else r--; if(r == numRows)&#123; flag = false; r-=2; &#125; if(r == 0)&#123; flag = true; &#125; &#125; string ret; for(string str : row) &#123; ret += str; &#125; return ret; &#125;&#125;; 进行模拟]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day5:rmdir命令]]></title>
    <url>%2F2019%2F03%2F19%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day5_rmdir%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rmdirrmdir (Remove Directory): 用来删除空目录，删除某目录时也必须具有对父目录的写权限。 语法： rmdir [OPTIONS] [DIRECTORY] 选项： --ignore-fail-on-non-empty 忽略仅由目录非空产生的所有错误 -p, 删除指定目录及其上级文件夹， -v, 输出处理的目录详情 操作：]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>rmdir</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day5:Longest Palindromic Substring]]></title>
    <url>%2F2019%2F03%2F19%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day5_Longest%20Palindromic%20Substring%2F</url>
    <content type="text"><![CDATA[题目:给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 题目链接：Longest Palindromic Substring C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//暴力，时间复杂度O(n*n*n)string longestPalindrome1(string s) &#123; int lens = s.size(); int maxlen = 0; int start = 0; for(int i = 0; i &lt; lens; i++)&#123; for(int j = i + 1; j &lt; lens; j++)&#123; int temp1 = i; int temp2 = j; while(temp1 &lt; temp2 &amp;&amp; s[temp1] == s[temp2]) &#123; temp1++; temp2--; &#125; if(temp1 &gt;= temp2 &amp;&amp; j - i + 1 &gt; maxlen)&#123; maxlen = j - i + 1; start = i; &#125; &#125; &#125; return s.substr(start, maxlen);&#125;//动态规划，时间复杂度O(n*n)string longestPalindrome2(string s) &#123; int lens = s.size(); bool dp[1000][1000]; memset(dp, 0, sizeof(dp)); int maxlen = 0; int start = 0; for(int i = 0; i &lt; lens; i++)&#123; for(int j = 0; j &lt;= i ; j++)&#123; if(i - j &lt; 2)&#123; if(s[i] == s[j]) dp[j][i] = true; else dp[j][i] = false; &#125; else&#123; if(s[i] == s[j] &amp;&amp; dp[j+1][i-1]) dp[j][i] = true; else dp[j][i] = false; &#125; if(dp[j][i] &amp;&amp; maxlen &lt; i - j + 1) &#123; maxlen = i - j + 1; start = j; &#125; &#125; &#125; return s.substr(start, maxlen);&#125;int main()&#123; string str1; cin&gt;&gt;str1; cout&lt;&lt;longestPalindrome1(str1)&lt;&lt;endl; cout&lt;&lt;longestPalindrome2(str1)&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day4:mkdir命令]]></title>
    <url>%2F2019%2F03%2F18%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day4_mkdir%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mkdir (Make Directory ): 若指定目录不存在则创建目录。在创建目录时，要求创建目录的用户具有写权限，并应保证新建的目录没有重名。 语法： mkdir [OPTIONS] [FILE] 选项： -m,设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask -p, 需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理 -v, 每次创建新目录都显示信息 操作：]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>mkdir</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day4:Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F03%2F18%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day4_Median%20of%20Two%20Sorted%20Arrays%2F</url>
    <content type="text"><![CDATA[题目:给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 题目链接：Median of Two Sorted Arrays C++：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(); int len2 = nums2.size(); vector&lt;int&gt; array = merge(nums1, nums2, len1, len2); return ((array[(len1+len2-1)/2]+array[(len1+len2)/2]))/2.0; &#125; vector&lt;int&gt; merge(vector&lt;int&gt; A, vector&lt;int&gt; B, int m, int n)//合并 &#123; vector&lt;int&gt; ret; int i = 0; int j = 0; while(i &lt; m &amp;&amp; j &lt; n) &#123; if(A[i] &lt;= B[j]) &#123; ret.push_back(A[i]); i ++; &#125; else &#123; ret.push_back(B[j]); j ++; &#125; &#125; if(i == m) &#123; while(j &lt; n) &#123; ret.push_back(B[j]); j ++; &#125; &#125; if(j == n) &#123; while(i &lt; m) &#123; ret.push_back(A[i]); i ++; &#125; &#125; return ret; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day3:ls命令]]></title>
    <url>%2F2019%2F03%2F17%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day3_ls%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[lsls (list) 列出目录内容以及目录详细信息 语法： ls [OPTIONS] [FILE] 选项：选项较多，背记常用选项 -a 显示当前目录所有文件 -l 显示当前目录文件的详细信息 -t 以时间顺序排序 -h 以人性化方式显示 -n 用数字的 UID,GID 代替名称 -R 递归列出所有目录的文件 -d 以文件名显示当前目录 -S 以文件大小排序 操作：]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day3:Longest Substring Without Repeating Characters]]></title>
    <url>%2F2019%2F03%2F17%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day3_Longest%20Substring%20Without%20Repeating%20Characters%2F</url>
    <content type="text"><![CDATA[题目:给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 题目链接：Longest Substring Without Repeating Characters C++： 123456789101112131415161718192021class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int lenS = s.size(); if (lenS &lt;= 1) return lenS; unordered_set&lt;char&gt; set; int ans = 0; int l = 0, r = 0; while (r &lt; lenS) &#123; while (set.count(s[r])) &#123; set.erase(s[l]); l++; &#125; set.insert(s[r]); ans = max(ans, int(set.size())); r++; &#125; return ans; &#125;&#125;; 运用了尺取思想，动态扩大尺子的长度，如果没有重复元素就让尺子的右边右移，如果有重复元素，则将尺子的左边右移，用ans中记录set出现的最大size即为最大的非重复连续子串。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day2:Add Two Numbers]]></title>
    <url>%2F2019%2F03%2F16%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day2_Add%20Two%20Numbers%2F</url>
    <content type="text"><![CDATA[题目:给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 题目链接：Add Two Numbers C++语言： 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* resultHead = new ListNode(0); ListNode *result = resultHead; int sumTwo = 0; int carry = 0; //进位 while(l1 || l2 || carry)&#123; sumTwo = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry; if(sumTwo &gt;= 10)&#123; sumTwo %= 10; carry = 1; &#125; else carry = 0; result-&gt;next = new ListNode(sumTwo); result = result-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; return resultHead-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day2:cd命令]]></title>
    <url>%2F2019%2F03%2F16%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day2_cd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cdcd(change directory),改变shell工作目录 语法： cd [OPTIONS] [FILE] 选项： -P 切换到真正的物理目录，而不是软连接目录 -L 强制遵循符号链接(懵逼) 操作：]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>cd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode每天刷day1:Two Sum]]></title>
    <url>%2F2019%2F03%2F15%2FLeetCode%E6%AF%8F%E5%A4%A9%E5%88%B7day1_Two%20Sum%2F</url>
    <content type="text"><![CDATA[题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 题目链接：Two Sum C++语言:1234567891011121314151617181920212223242526272829303132333435363738//暴力求解，时间复杂度O(n*n)class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; twoSum; int lenNums = nums.size(); for(int i = 0;i &lt; lenNums; i++)&#123; for(int j = i + 1; j&lt;lenNums; j++)&#123; if((nums[i] + nums[j]) == target)&#123; twoSum.push_back(i); twoSum.push_back(j); &#125; &#125; &#125; return twoSum; &#125;&#125;;//利用hash查找，时间复杂度降到O(n);class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; twoSum; map&lt;int,int&gt; m; int lenNums = nums.size(); int tmp; for(int i = 0;i &lt; lenNums; i++)&#123; if(m.count(nums[i]) &gt; 0) &#123; twoSum.push_back(m[nums[i]]); twoSum.push_back(i); break; &#125; tmp = target - nums[i]; m.insert(pair&lt;int, int&gt;(tmp, i)); &#125; return twoSum; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day1:pwd命令]]></title>
    <url>%2F2019%2F03%2F15%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day1_pwd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[pwdpwd (print work directory)打印当前工作目录，以绝对路径方式显示当前用户的工作目录 语法： pwd [OPTION] 选项： -L --logical //当前目录为连接路径时，显示链接的路径 -P --physical //显示实际的物理路径，而不是链接路径 操作：]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>pwd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:二叉树存储与遍历]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E4%B8%8E%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树每个结点最多有两个子树的树，左右子树是有顺序的。就算某个结点仅有一棵子树，也需要分左右子树。二叉树的第i层最多有2^(i-1)个结点 特殊的二叉树： 斜树 满二叉树 完全二叉树 二叉树的存储结构 二叉树的顺序存储结构：对斜树存储很不友好二叉树的链式存储结构：使用二叉链表，用两个指针分别指向左右子树。 12345typedef struct BiTNode&#123; TElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 二叉树的遍历按照某种次序依次访问二叉树中所有的结点，使每一个结点都被访问一次 前序遍历：二叉树如果为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。根左右 中序遍历：二叉树如果为空，则空操作返回，否则从根结点开始，然后中序遍历左子树，然后访问根结点，再中序遍历右子树 ，左根右 后续遍历：二叉树如果为空，则空操作返回，否则从左到右先叶子后结点方式遍历左右子树，然后访问根结点，左右根 层序遍历：一层层从做到右遍历 以前序遍历输出层数。 ~~#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;typedef char ElemType;typedef struct BiTNode{ ElemType data; struct BiTNode lchild, rchild;}BiTNode, BiTree;void CreateBiTree(BiTree T){ char c; scanf(“%c”, &amp;c); if(‘#’ == c){ T = NULL; } else { T = (BiTNode )malloc(sizeof(BiTNode)); (T)-&gt;data = c; CreateBiTree(&amp;(T)-&gt;lchild); CreateBiTree(&amp;(T)-&gt;rchild); }}void visit(char c,int level){ printf(“%c 位于第 %d 层\n”, c, level);}void PreOrderTraverse(BiTree T, int level){ if(T){ visit(T-&gt;data,level); PreOrderTraverse(T-&gt;lchild, level + 1); PreOrderTraverse(T-&gt;rchild, level + 1); }}int main(){ int level = 1; BiTree T = NULL; CreateBiTree(&amp;T); PreOrderTraverse(T, level); return 0;}~~ 前序遍历算法: 12345678void PreOrderTraverse(BiTree T)&#123; if(T == NULL) return ; printf("%c", T-&gt;data); //根 PreOrderTraverse(T-&gt;lchild); //左 PreOrderTraverse(T-&gt;rchild); //右&#125; 中序遍历算法: 12345678void InOrderTraverse(BiTree T)&#123; if(T == NULL) return ; InOrderTraverse(T-&gt;lchild); //左 printf("%c", T-&gt;data); //根 InOrderTraverse(T-&gt;rchild); //右&#125; 后序遍历算法: 12345678void PostOrderTraverse(BiTree T)&#123; if(T == NULL) return ; PostOrderTraverse(T-&gt;lchild); //左 PostOrderTraverse(T-&gt;rchild); //右 printf("%c", T-&gt;data); //根) 二叉树遍历常考: 已知前序遍历序列和中序遍历序列,求这颗二叉树后序遍历序列? 已知后序遍历序列和中序遍历序列,求这颗二叉树前序遍历序列?方法: 1.首先通过前序遍历序列(后序遍历序列)判断根部的结点位置2.再通过中序遍历和根结点位置判断左右子树的结点,在根结点左边的为左子树结点,右边为右子树结点3.最后通过前序遍历序列(后序遍历序列)判断左子树和右子树中的层级关系,通过中序遍历序列判断兄弟之间的关系 得出树后再通过树反推一遍树的前序和中序(后序和中序)验证.]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:树的存储]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[树Tree是n（n &gt;= 0）个结点的有限集。当n = 0时为空树，在任意一颗非空树中存在以下性质： 有且仅有一个特定的名字为根的结点 当n&gt;1 时，其余结点可以分为m（m&gt;0）个互不相交的有限集 T1,T2….Tm，其中每一个集合本身又是一颗树，并且称为根的子树（SubTree）。度：结点拥有子树的数量称为结点的度（Degree），树的度取树内各结点度的最大值度为0称为 叶结点结点的层次：根为第一层，深度为最大的层数 树的存储结构双亲表示法以双亲为索引每一个结点中除了包含自身数据，还有双亲结点的索引 12345678910int tree_size = 100;typedef struct PTNode&#123; int data; //数据结点 int parent;//双亲位置&#125;PTNode;typedef struct&#123; PTNode nodes[tree_size]; int r; //根的位置 int n;//结点的数目&#125; 找某结点的parent，可以通过parent指针进行查找，时间复杂度为O(1)但是找某结点的children，需要遍历整个树才行，所以我们可以在PTNode结构体里面增加左child和右child，也能够找到节点的children。再但是如果需要了解sibling之间的关系，还可以在PTNode结构体中添加左sibling 和右sibling…等等 孩子表示法采用邻接表进行存储，以每一个结点为链表头，将孩子结点依次尾插到链表头 双亲孩子表示法在链表头进行存储一下双亲即可 1234567891011121314151617181920int treesize = 100;typedef struct CTNode&#123; int child; //孩子结点的下标 struct CTNode *next; //指向下一个孩子的指针&#125; *ChildPtr;typedef struct&#123; int data; int parent; ChildPtr firstchild;&#125; CTBox;typedef struct&#123; CTBox nodes[treesize]; int r; int n;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树的存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:字符串字符匹配]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[字符串字符串的存储结构和线性表相同，分为顺序存储和链式存储字符串比较比较字符串中每一个字符的ASCII码的值 字符串匹配问题：方法一：BF算法（Brute Force）暴力求解算法描述：两个字符串母串str1和子串str2，长度分别为len1和len2，首先将str1[0]和str2[0]比较，若相等，则进行下一位比较，直到子串str2匹配完，则结束，若不相等，则子串后移以为继续相同操作 时间复杂度为O(len1*len2) 方法二: KMP算法KMP算法最需要关注的点是子串，而不是母串 下面几个思考将一步步优化BF算法，得出KMP算法。思考一如下图示：子串是不重复的，那么我们匹配到下标为2这个元素的时候，子串失配了，按照BF算法我们会用子串的a元素和母串的b元素进行匹配。但是这样是错误的回溯，所以我们希望下一次匹配是如下图所示，这样可以避免错误回溯 思考二如下图所示，如果子串含有重复的元素，按照思考一中的方案是不可行的，所以我们要保证所有具有可行性的方案能够检验匹配下图第二次匹配应该从下标2进行匹配所以我们只需要对子串进行操作，记录子串应该在哪跳过一些错误的回溯KMP算法中通过next数组对此进行了一个记录。 next数组是当子串失配时，next数组对应的元素可以指导子串的哪一个元素进行下一轮的匹配 思考三如何推出next数组：将思考一二中的例子自行推断如图将子串对应的next数组填入，填入原则遵循：next数组是当子串失配时，next数组对应的元素可以指导子串的哪一个元素进行下一轮的匹配所以上图下标为2时失配，next数组指向0则如下图示，从子串下标为0处开始匹配：其中-1位特判，当是第一个字符就不匹配则第一个字符与母串下一个字符进行匹配 将思考二的next数组填入：next数组是当子串失配时，next数组对应的元素可以指导子串的哪一个元素进行下一轮的匹配（重要内容说三遍！！）所以上图下标为4时失配，next数组指向2则如下图示，从子串下标为2处开始匹配：而next数组的到原理其实是子串当前位之前的串的前缀和后缀最大相同的值： 如思考二例子中：下标为4的字符之前的串为abab，前缀和后缀最大相同的为ab，长度为2，对应next为2下标为3的字符之前的串为aba， 前缀和后缀最大相同的为a ，长度为1，对应next为1依次可得对应的next数组 思考四如何编码求得next数组？由思考三可知：求next数组即为求前缀和后缀最大相同的值我们令i表示前缀，j表示后缀，子串为str2 分步解决：1、当出现前缀和后缀相同的情况，即是例子中i = 0，j = 2这种情况，得出next[3] = 1那么这种情况即为： 123456if(str2[i] == str2[j] ) //前缀等于后缀&#123; i++; j++; next[j] = i;&#125; 当i = 1 ， j = 3 时，任然如此，可以得到next[4] = 22、在情况一中，我们并没有考虑当 前缀和后缀不相等的情况，所以当不相等时 12345678910if(str2[i] == str2[j] ) //前缀等于后缀&#123; i++; j++; next[j] = i;&#125;else&#123; i = next[i] //见解析a&#125; 解析a：前缀和后缀的匹配也变成了子串和母串的匹配问题，但是此时的局部的next数组已经相对来说已经完成，我们将后缀串比作母串，前缀串比作子串，则我们需要将 i 回溯到next数组指向的位置，进行跳跃匹配并防止思考二中出现的问题 最后补全初始情况，以及i，j，next[0]的初始值，匹配的范围得出代码： 12345678910111213141516171819//len为字符串str2长度void get_next(char *str2, int *next, int len)&#123; next[0] = -1; int i = -1; int j = 0; while(j &lt; len - 1)&#123; if(-1 == i || str2[i] == str2[j]) //前缀等于后缀 &#123; i++; j++; next[j] = i; &#125; else &#123; i = next[i]; //见解析a &#125; &#125;&#125; KMP算法实现： 123456789101112131415161718192021int Index_KMP(char *str1, char *str2)&#123; int i = 0; int j = 0; int next[255]; int len1 = strlen(str1); int len2 = strlen(str2); get_next(str2, next, len2); while(i &lt; len1 &amp;&amp; j &lt; len2)&#123; if(-1 == j || str1[i] == str2[j])&#123; i++; j++; &#125; else&#123; j = next[j]; &#125; &#125; if(j == len2) return i - j; else return -1;//没有找到 &#125; KMP算法基本完成！ KMP算法优化当出现此种特例，按照原先的KMP算法思想，母串中的b将与子串的每一个元素进行匹配，所以我们需要更改get_next函数将元素相同的情况统一起来，使next数组进行有效指导。更改代码如下： 12345678910111213141516171819202122void get_next(char *str2, int *next, int len)&#123; next[0] = -1; int i = -1; int j = 0; while(j &lt; len - 1)&#123; if(-1 == i || str2[i] == str2[j]) //前缀等于后缀 &#123; i++; j++; //更改next[j] = i; if(str2[i] != str2[j]) next[j] = i; else//如果相同 next[j] = next[i]; &#125; else &#123; i = next[i];//见解析a &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串匹配</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:栈与队列]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈Stack 是一个后进先出的线性表，它要求只在表尾进行删除和插入操作。简单理解：具有特殊限制的线性表，限制要求如上。出栈：pop();入栈：push();清空栈：clear(); 题目：利用栈的特点，将二进制装换为十进制数例如二进制数：100110将二进制数按位入栈| ||-|| 0||1||1||0||0||1|然后通过出栈操作进行计算转换 题目：利用栈的特点，将二进制转换为八进制利用两个栈，一个栈存二进制数，另一个栈用做记录转换为八进制的数，按顺序弹出，得到转换的八进制。 栈的应用：利用栈计算后缀表达式如中缀表达式：1+(2-5)6如后缀表达式为：1 2 5 - 6 +声明栈A将后缀表达式 数字依次入栈A，如果出现符号，则取出栈顶两个元素进行操作，再将结果入栈，直到后缀表达式遍历完成，弹出栈中的结果便是答案 出现符号”-“ 出现符号”*” 出现符号”+” 遍历完成 5 6 2 -3 -3 -18 -18 1 1 1 1 1 -17 ———&gt;从左向右看，每一列为一个栈的状态利用栈将中缀表达式转换为后缀表达式1+（2-3）*4 + 10/5从左到右遍历中缀表达式的每一个数字和符号，数字直接输出，如果是符号，需要判断其与栈顶书号的优先级，如果是右括号或者优先级低于栈顶符号，则栈顶元素依次出栈输出，直到遇到左括号，或者栈为空，再将判断的符号入栈。 将上面两点结合，就可以完成中缀表达式计算器实现原理：声明两个栈A,B，栈A进行计算后缀表达式，栈B进行中缀表达式的转换，中缀表达式转换过程中，将输出的数字和符号依次入栈A进行计算，如此可以得到结果。 队列queue是只允许在一端进行插入操作，在另一端进行删除操作的线性表，具有先进先出的特性。简单理解：食堂排队打饭 和栈相反，队列一般用链表来实现，栈一般用顺序表来实现。 队列如果用顺序存储：每一次取队头，后面的每一个元素都需要向前移动，会增加耗时如果增加一个灵活指针当队头，随着出队列，入队列操作增多，会有大部分空闲区域，同时可能会倒是数据溢出。为解决上面的问题，可以通过循环队列解决通过灵活改变头指针和尾指针 ，头指针和尾指针分别在出队和入队操作进行+1移位，同时用取模操作让，头尾指针不断循环，当头尾指针相等，便是队列已满或者队列已空]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:线性表]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[修改于:2019/3/19, 添加线性表顺序存储结构代码，已调试可运行。 线性表由零个或者多个数据元素组成的有限序列，每个元素最多只有一个前驱和后继。 List的抽象数据类型定义： ADT 线性表(List) Data 数据 Operation 操作123456789InitList(*L)//初始化ListEmpty(L)//判断是否为空表//增删改查ClearList(*L)//将线性表清空GetElem(L,i,*e)//将线性表i位置元素返回给eListCreate(*L)//生成线性表LocateElem(L, e)//返回线性表中e元素的位数，不存存在返回falseListInsert(*L, i, e)//将数据e插入到下标i处ListDelete(*L, i, *e)//将线性表中i处元素删除，并返回到*e 线性表的顺序存储结构需要封装三个属性： 存储空间的起始位置 最大存储容量 线性表当前长度 查找算法时间复杂度为O(1)增删改的算发时间复杂度为O(n) 优点:无须为表中元素之间的逻辑关系增加额外的存储空间，可以快速的存取表中任一位置的元素。缺点:插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量，并且容易造成空间碎片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 20 //定义空间初始化#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int ElemType;typedef int Status;typedef struct&#123; ElemType *data;//用数组存储数据元素，最大值为MAXSIZE int length;//线性表当前长度&#125;SqList;//初始化线性表Status InitSqList(SqList *L)&#123; L-&gt;data = (ElemType*) malloc(MAXSIZE*sizeof(ElemType)); if(L-&gt;data == NULL) &#123; printf("初始化失败"); return ERROR; &#125; L-&gt;length = 0; return OK;&#125;Status ListCreate(SqList *L)&#123; int i,n; printf("请输入线性表的长度(长度小于20): \n"); scanf("%d",&amp;n); L-&gt;length = n; printf("请输入即将创建的线性表中的元素：\n"); for (i = 0; i &lt;n; i++) &#123; scanf("%d", &amp;L-&gt;data[i]); &#125; return OK;&#125;//判断线性表是否为空Status ListEmpty(SqList L)&#123; if(L.data == NULL) return ERROR; if(0 == L.length) return TRUE; else return FALSE;&#125;//将线性表清空Status ClearList(SqList *L)&#123; if(0 == L-&gt;length) &#123; printf("顺序表为空"); return ERROR; &#125; int cnt; for(cnt = 0; cnt &lt; L-&gt;length; cnt++) L-&gt;data[cnt] = 0; L-&gt;length = 0; return OK;&#125;//将线性表L中的第i个位置的元素返回给eStatus GetElem(SqList L, int i, ElemType *e)&#123; if(0 == L.length || i &lt; 0 || i &gt; L.length) &#123; printf("顺序表为空，或者i输入错误"); return ERROR; &#125; *e = L.data[i-1]; return OK;&#125;Status LocateElem(SqList L, ElemType e)&#123; if(0 == L.length) &#123; printf("顺序表为空"); return ERROR; &#125; int cnt; for(cnt = 0; cnt &lt; L.length; cnt++) &#123; if(L.data[cnt] == e) return cnt; &#125; return FALSE;&#125;Status PrintList(SqList *L)&#123; if(0 == L-&gt;length) &#123; printf("顺序表为空"); return ERROR; &#125; int i; for(i = 0; i &lt; L-&gt;length; i++)&#123; i &lt; L-&gt;length - 1 ? printf("%d ", L-&gt;data[i]) : printf("%d\n", L-&gt;data[i]); &#125; return OK;&#125;Status ListInsert(SqList *L, int i, ElemType e)&#123; if(0 == L-&gt;length || i &lt; 0 || i &gt;= L-&gt;length) &#123; printf("顺序表为空，或者i输入错误"); return ERROR; &#125; if(L-&gt;length == MAXSIZE) &#123; printf("顺序表已经满了"); return ERROR; &#125; if(i &lt; L-&gt;length) &#123; int k; for( k = L-&gt;length-1; k &gt;= i-1; k--) &#123; L-&gt;data[k+1] = L-&gt;data[k]; &#125; &#125; L-&gt;data[i-1] = e; L-&gt;length++; return OK;&#125;Status ListDelete(SqList *L, int i, ElemType *e)&#123; if(0 == L-&gt;length || i &lt; 0 || i &gt;= L-&gt;length) &#123; printf("顺序表为空，或者i输入错误"); return ERROR; &#125; if(L-&gt;length == 0) &#123; printf("顺序表已经空了"); return ERROR; &#125; *e = L-&gt;data[i-1]; if(i &lt; L-&gt;length) &#123; int k; for(k = i-1; k &lt; L-&gt;length; k++) &#123; L-&gt;data[k] = L-&gt;data[k+1]; &#125; &#125; L-&gt;length--; return OK;&#125;Status ListLength(SqList L)&#123; return L.length;&#125; 线性表的链式存储结构单链表：第一个节点存储位置叫做头结点，最后一个结点指针为空头指针存在于头结点，链表必须存在头指针，在每一个节点中，存储数据和指向下一个节点的指针C语言描述：12345typedef struct Node&#123; ElemType data; struct Node *Next;&#125; Node;typedef struct Node *LinkList//定义LinkList 建立单链表：1、头插法建立无头节点单链表2、尾插法建立单链表 单链表的整表删除：从头结点开始逐个删除 查找链表第i个数据：需要声明指向头结点的指针p，通过移动p到i位置，得到链表数据所以时间复杂度为O(n)增删改只需要通过指针的修改也是O(n)但是相对于顺序结构存储，增删改操作越是频繁，单链表结构更具有优势，查找操作越多，顺序表更具有优势。 题目：快速找到未知长度单链表的中间节点 普通方法：遍历单链表确定长度L，再遍历找到L/2处节点的位置 O(3L/2)优化：快慢指针(标尺思想)设置两个指针，慢指针步长为1，快指针步长为2 ，当快指针到达链表尾部，慢指针就到达中间节点O(L/2) 判断单链表是否有环方法一：通过两个指针p，q，q以步长为1遍历到链表尾，q每移动一个位，更新q移动的距离Q，p遍历到q指针的位置，并得到p指针移动的距离P，如果P!=Q，那么单链表有环。 方法二：通过快慢指针，q每次走一步，p每次走两步，p每走一步都进行判断，如果p==q了，那么就意味着有环。 静态链表利用数组代替指针建立游标，存放下一节点数据的位置通常数据数组的第一个和最后一个元素不存放数据，未使用的数据数组称之为备用链表。数据数组已存放数据的最后一个元素的游标为0游标第一个元素存放备用链表的第一个节点下标游标最后一个元素存放第一个有数值元素的下标，相当于单链表的头结点。 其思想极为巧妙 循环链表将单链表的尾部节点的由空指针指向头结点，循环链表和单链表的主要区别是空表的判断，单链表判断头指针下一元素是不是等于null，循环链表则是判断是不是等于头指针。 问题: 用循环链表模拟约瑟夫问题。 双向链表将单链表节点再增加一个前驱节点，就形成了双向链表。C语言描述：12345typedef struct DualNode&#123; ElemType data; struct DualNode *prior; struct DualNode *next;&#125; 双向链表即时牺牲空间换取时间。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>线性表的存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux每天记day7:touch命令]]></title>
    <url>%2F2019%2F03%2F11%2FLinux%E6%AF%8F%E5%A4%A9%E8%AE%B0day7_touch%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[touchtouch命令将每个文件的访问时间和修改时间改为当前时间,不存在的文件参数创建为空，除非有-c或-h选项 语法: touch [OPTION]... FILE... 选项: -a, 只更改访问时间 -c, 不创建任何文件 -d, --date=字符串 使用指定字符串表示时间而非当前时间 -h,会影响符号链接本身，而非符号链接所指示的目的地(当系统支持更改符号链接的所有者时，此选项才有用) -m,只更改修改时间 -r, 使用指定文件的时间属性而非当前时间 -t 使用[[CC]YY]MMDDhhmm[.ss] 格式的时间而非当前时间 --time=WORD 使用WORD 指定的时间：access、atime、use 都等于-a选项的效果，而modify、mtime 等于-m 选项的效果 操作:]]></content>
      <categories>
        <category>Linux指令</category>
      </categories>
      <tags>
        <tag>Linux文件和目录管理</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:时间复杂度和空间复杂度]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度和空间复杂度简单分析算法效率的度量方法：1、事后统计法：主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序进行测试比较。2、事前分析估算方法：在编写程序前，根据统计方法对算法进行估算。 高级语言程序在计算机上运行时间取决因素： 1、算法的方案2、编译器产生的代码的质量3、问题输入的规模3、机器指令的的速度 1、3为当前需要优化的点 例子：计算1~n的和算法一：1234int sum = 0,n = 100;//执行了1次for(int i = 1; i &lt;= n; i++)&#123; //执行了n+1次 sum += i; //执行了n次&#125; 算法二：12int sum = 0,n = 100;//执行了1次sum = (1 + n) * n / 2;//执行了1次 上面两个算法就是1和n的区别不是2n + 2 和 2的区别，研究算法复杂度侧重是研究算法随着输入规模增大扩大增长量的一个抽象，而不是定位要执行多少次，有一种极限的思想。 辅助理解：算法A需要执行3n+3次操作，算法B需要执行4n+1次操作，算法A和B哪一个更快|n|算法A|算法A（抽象为3n）|算法B|算法B（抽象为4n）||–|–|–|–|–||1| 6|3| 5 |4||2| 9|6| 9 |8||10| 33|30| 41 |40||100| 303|300| 401 |400||1000| 3003|3000| 4001 |4000| 由图可以看出 当n=1时 算法B比算法A更好当n&gt;=2时 算法A开始比算法B要好同时我们也发现：抽象的规律和原本算法一致，所以可以忽略常数如果算法C执行3n^ 2+3n+3次,算法D执行3n+3次，算法E执行3n^ 2次，通过极限抽象可以得出算法C为3n^ 2,算法D为3n，算法E为3n^ 2 时间复杂度简单理解：执行次数=时间一般用大O记法进行记录时间复杂度 分析算法时间复杂度方法： - 可以忽略所以加法常数用常数1来表示 - 然后保留最高项 - 如果最高项存在且不为1，则去除这个项相乘的常数例如：上面算法CDE 已经完成前两步，所以我们可以得出算法CDE分别为：O(n^ 2)，O(n)，O(n^2)。 常用时间复杂度耗时：常数阶&lt;线性阶&lt;平方阶&lt;对数阶&lt;nlogn阶&lt;立方阶&lt;指数阶； 最坏情况与平均情况平均运行时间是期望的运行时间，最坏运行时间是一种保证 空间复杂度简单理解：就是关于n的语句所占的存储空间 一般来说，时间和空间是可以相互转换的。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>时间空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法:数据结构的存储方式与常用结构]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[修改于 2019/3/18 绪论一般来说，数据结构分为：1、逻辑结构2、物理结构 逻辑结构有四种： 集合结构 线性结构 树形结构 图形结构 物理结构实际上就是如何将数据元素储存到计算机的存储器中(如：硬盘、软盘等)，而数据存储结构的形式有两种：顺序存储和链式存储1、顺序存储：数据元素存放的地址是连续的，其数据间的逻辑关系和物理关系是一致的。(例如：c语言中的数组)2、链式存储：数据元素存放是在任意的存储单元，可以连续也不可以连续，取而代之的就是需要指针存放下一元素的地址 数据类型：是指一组性质相同的值的集合以及定义在次集合上的一些操作的总称 抽象数据类型(ADT)是指一个数学模型及定义在该模型上的一组操作。其意义可以将我们实际生活中的大问题分解为多个规模小并且容易处理的问题，然后建立一个计算机能处理的数据模型。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构常用存储方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1323]]></title>
    <url>%2F2018%2F09%2F06%2FHDU1232%2F</url>
    <content type="text"><![CDATA[畅通工程Time Limit: 4000/2000 MS (Java/Others)Memory Limit: 65536/32768 K (Java/Others) Problem Description：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input：测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说 3 3 1 2 1 2 2 1 这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output：对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 2 1 3 4 3 3 3 1 2 1 3 2 3 5 2 1 2 3 5 999 0 0 Sample Output1 0 2 998]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Hdu</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集详解]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集（Union-find Sets）是一种非常巧妙而且实用的数据结构，主要用于处理一些不想交的集合合并问题。具体包含了两个函数：Union()用来合并和Find()用来查找 以及一个整型数组用来记录每个点的前导点是什么。 代码实现int pre[1050]//记录第i个节点的父亲节点 int Find(int root)//查找根节点 { int son,temp; son=root; while(root != pre[root]){//寻找父亲节点 root = pre[root]; } while(son != root){//路径压缩 temp=pre[son]; pre[son]=root; son=temp; } return son; } void Union(int root1,int root2){//判断是否连通，不连通就合并 int x,y; x=Find(root1); y=Find(root2); if(x!=y)//如果不连通，就把它们所在的连通分支合并 pre[x] = y; } 算法详解pre[]数组最开始初始化为为pre[i]=i，即表明这pre[i]的父亲节点是i，Union()函数则是将两个节点进行联通，其中Union中用到了Find()函数是找自己的父亲节点判断是否联通，如果不连通就进行pre[x]=y操作，表示为将x节点的父亲节点设置为y。其中Find()函数通过递归判断本节点的上一节点的父亲节点是不是本身，直到找到一个节点的父亲节点是本身的节点作为父亲节点。 在Find()函数中有一个路径压缩算法，是由于Union()函数只是为了连接，所以谁作为父亲节点是随机的，因此最后的树状结构可能很复杂，查找的效率就很低，那么就需要进行路径压缩，让所有的父子节点关系都变成两级结构。 经典例题传送门： HDU 1232畅通工程]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Everyone]]></title>
    <url>%2F2018%2F09%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎大家无意间访问我的小站(点我),blog建了很久了,但是一直没有更新,现在会每天更新一些博客,高产似母猪! 自己会时不时更新一下LeetCode上写的题目(哈哈哈没有解析)同时会记录一些学习的笔记和分享然后然后就没有了哈哈哈大家也可以访问我的CSDN博客(点我)为啥呢?因为是一样的哈哈哈 由于是建站第一篇post所以置顶晾着,自己时不时的修改一下~]]></content>
      <categories>
        <category>简记</category>
      </categories>
      <tags>
        <tag>Hi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04超级简单的安装wine QQ教程]]></title>
    <url>%2F2018%2F07%2F25%2Fubuntu18.04%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%89%E8%A3%85wine%20QQ%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[更新于2019年3月25日更新内容: - 解决W2KSP4_EN.EXE文件和InstMsiW.exe文件下载慢的问题 - 解决安装qq后第二次不知道怎么打开或者点击图标无效问题 解决方案见文末. 第一步打开 Ubuntu Software，搜索wine ##第二步下载wine和Winetricks，并打开Winetricks（如图）ps：有可能会跳出一些提示框，直接点ok ##第三步选择安装一个windows应用，并选择qq安装ps：会下载安装包以及一些插件，可能不能一次成功，再进行一次相同的操作即可 ##第四步安装QQ 完成ps：这个Winetricks是可以对QQ进行配置的，也可以安装一些其他windows上的软件，大家可以自己探索！本文为原创，转载请注明出处，谢谢！ 问题解决:解决W2KSP4_EN.EXE文件和InstMsiW.exe文件下载慢的问题说明:有些同学会出现上述两个文件以几k每秒下载,下的非常慢(下的很快可以忽略哈哈),所以我将我自己可运行的文件上传到了网盘大家可以自行下载,大家自行将文件放到相应文件夹即可.W2KSP4_EN.EXE文件 提取码: f2tv cp W2KSP4_EN.EXE ~/.cache/winetricks/win2ksp4/ //如果win2ksp4文件夹不存在,请自行添加 InstMsiW.exe 提取码: 41kq cp InstMsiW.exe ~/.cache/winetricks/msls31/ //如果msls31文件夹不存在,请自行添加 问题解决:解决安装qq后第二次不知道怎么打开或者点击图标无效问题说明:在Ubuntu中桌面快捷方式是一个以.desktop结尾的文件,有些同学打不开的原因主要还是自动生成的腾讯QQ.desktop文件有问题,我们自己修改一下就可以了~ 文件位置: ~/.local/share/applications/wine/Programs/腾讯软件/QQ/ 上面是我的腾讯QQ.desktop文件路径,可能有差异,但是肯定是在 ~/.local/share/applications/wine/中接下来便是修改腾讯QQ.desktop文件,大家可以用vim 或者 gedit(新手推荐)修改 [Desktop Entry] # 图标显示的名字 Name=QQ # 中文模式的名字 Name[zh_CN]=QQ # 英文模式的名字 Name[zh_EN]=QQ # 这是这个这个桌面文件运行的指令,其实大家在终端中运行下面这条指令,也是可以打开自己的qq的. Exec=wine ~/.wine/drive_c/Program\ Files\ \(x86\)//Tencent/QQ/Bin/QQ.exe/ # 桌面图标 Icon=QQ # 是否使用终端 Terminal=false X-MultipleArgs=false # 启动器类型 Type=Application # 采用的编码 Encoding=UTF-8 # 应用类型 Categories=Application;Utility;Network;InstantMessaging; # 启动通知 StartupNotify=false 将上面代码复制修改腾讯QQ.desktop文件(中文已经做了注释,可直接复制使用),然后大家再点击qq的图标就可以打开QQ了(大家也可以通过这个方式来创建或者修改其他桌面文件) 上述两个问题亲测有效,有问题评论交流~]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>wine qq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于STL]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%85%B3%E4%BA%8ESTL%2F</url>
    <content type="text"><![CDATA[前言：在某文库上下载的文档，觉得讲的不错，做此分享。 作为C++标准不可缺少的一部分，STL应该是渗透在C++程序的角角落落里的。STL不是实验室里的宠儿，也不是程序员桌上的摆设，她的激动人心并非昙花一现。本教程旨在传播和普及STL的基础知识，若能借此机会为STL的推广做些力所能及的事情，到也是件让人愉快的事情。 1 初识STL：解答一些疑问1.1 一个最关心的问题：什么是STL“什么是STL？”，假如你对STL还知之甚少，那么我想，你一定很想知道这个问题的答案，坦率地讲，要指望用短短数言将这个问题阐述清楚，也决非易事。因此，如果你在看完本节之后还是觉得似懂非懂，大可不必着急，在阅读了后续内容之后，相信你对STL的认识，将会愈加清晰、准确和完整。不过，上述这番话听起来是否有点像是在为自己糟糕的表达能力开脱罪责呢？:）不知道你是否有过这样的经历。在你准备着手完成数据结构老师所布置的家庭作业时，或者在你为你所负责的某个软件项目中添加一项新功能时，你发现需要用到一个链表(List)或者是映射表（Map）之类的东西，但是手头并没有现成的代码。于是在你开始正式考虑程序功能之前，手工实现List或者Map是不可避免的。于是……，最终你顺利完成了任务。或许此时，作为一个具有较高素养的程序员的你还不肯罢休（或者是一个喜欢偷懒的优等生:），因为你会想到，如果以后还遇到这样的情况怎么办？没有必要再做一遍同样的事情吧！ 如果说上述这种情形每天都在发生，或许有点夸张。但是，如果说整个软件领域里，数十年来确实都在为了一个目标而奋斗–可复用性（reusability），这看起来似乎并不夸张。从最早的面向过程的函数库，到面向对象的程序设计思想，到各种组件技术（如：COM、EJB），到设计模式（design pattern）等等。而STL也在做着类似的事情，同时在它背后蕴涵着一种新的程序设计思想–泛型化设计（generic programming）。 继续上面提到的那个例子，假如你把List或者map完好的保留了下来，正在暗自得意。且慢，如果下一回的List里放的不是浮点数而是整数呢？如果你所实现的Map在效率上总是令你不太满意并且有时还会出些bug呢？你该如何面对这些问题？使用STL是一个不错的选择，确实如此，STL可以漂亮地解决上面提到的这些问题，尽管你还可以寻求其他方法。 说了半天，到底STL是什么东西呢？STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。这种现象有些类似于Microsoft Visual C++中的MFC（Microsoft Foundation Class Library），或者是Borland C++ Builder中的VCL(Visual Component Library)，对于此二者，大家一定不会陌生吧。 从逻辑层次来看，在STL中体现了泛型化程序设计的思想（generic programming），引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术。 从实现层次看，整个STL是以一种类型参数化（type parameterized）的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。如果查阅任何一个版本的STL源代码，你就会发现，模板作为构成整个STL的基石是一件千真万确的事情。除此之外，还有许多C++的新特性为STL的实现提供了方便。 不知你对这里一下子冒出这么多术语做何感想，希望不会另你不愉快。假如你对它们之中的大多数不甚了解，敬请放心，在后续内容中将会对这些名词逐一论述。正如开头所提到的。 有趣的是，对于STL还有另外一种解释–STepanov &amp; Lee，前者是指Alexander Stepanov，STL的创始人；而后者是Meng Lee，她也是使STL得以推行的功臣，第一个STL成品就是他们合作完成的。这一提法源自1995年3月，Dr.Dobb’s Journal特约记者, 著名技术书籍作家Al Stevens对Alexander Stepanov的一篇专访。 1.2 追根溯源：STL的历史在结识新朋友的时候，大多数人总是忍不住想了解对方的过去。本节将带您简单回顾一下STL的过去。 被誉为STL之父的Alexander Stepanov，出生于苏联莫斯科，早在20世纪70年代后半期，他便已经开始考虑，在保证效率的前提下，将算法从诸多具体应用之中抽象出来的可能性，这便是后来泛型化思想的雏形。为了验证自己的思想，他和纽约州立大学教授Deepak Kapur，伦塞里尔技术学院教授David Musser共同开发了一种叫做Tecton的语言。尽管这次尝试最终没有取得实用性的成果，但却给了Stepanov很大的启示。 在随后的几年中，他又和David Musser等人先后用Schema语言（一种Lisp语言的变种）和Ada语言建立了一些大型程序库。这其间，Alexander Stepanov开始意识到，在当时的面向对象程序设计思想中所存在的一些问题，比如抽象数据类型概念所存在的缺陷。Stepanov希望通过对软件领域中各组成部分的分类，逐渐形成一种软件设计的概念性框架。 1987年左右，在贝尔实验室工作的Alexander Stepanov开始首次采用C++语言进行泛型软件库的研究。但遗憾的是，当时的C++语言还没有引入模板（template）的语法，现在我们可以清楚的看到，模板概念之于STL实现，是何等重要。是时使然，采用继承机制是别无选择的。尽管如此，Stepanov还是开发出了一个庞大的算法库。与此同时，在与Andrew Koenig（前ISO C++标准化委员会主席）和Bjarne Stroustrup（C++语言的创始人）等顶级大师们的共事过程中，Stepanov开始注意到C/C++语言在实现其泛型思想方面所具有的潜在优势。就拿C/C++中的指针而言，它的灵活与高效运用，使后来的STL在实现泛型化的同时更是保持了高效率。另外，在STL中占据极其重要地位的迭代子概念便是源自于C/C++中原生指针（ native pointer）的抽象。 1988年，Alexander Stepanov开始进入惠普的Palo Alto实验室工作，在随后的4年中，他从事的是有关磁盘驱动器方面的工作。直到1992年，由于参加并主持了实验室主任Bill Worley所建立的一个有关算法的研究项目，才使他重新回到了泛型化算法的研究工作上来。项目自建立之后，参与者从最初的8人逐渐减少，最后只剩下两个人–Stepanove本人和Meng Lee。经过长时间的努力，最终，信念与汗水所换来的是一个包含有大量数据结构和算法部件的庞大运行库。这便是现在的STL的雏形（同时也是STL的一个实现版本–HP STL）。 1993年，当时在贝尔实验室的Andrew Koenig看到了Stepanove的研究成果，很是兴奋。在他的鼓励与帮助下，Stepanove于是年9月的圣何塞为ANSI/ISO C++标准委员会做了一个相关演讲（题为”The Science of C++ Programming”），向委员们讲述了其观念。然后又于次年3月，在圣迭戈会议上，向委员会提交了一份建议书，以期使STL成为C++标准库的一部分。尽管这一建议十分庞大，以至于降低了被通过的可能性，但由于其所包含的新思想，投票结果以压倒多数的意见认为推迟对该建议的决定。 随后，在众人的帮助之下，包括Bjarne Stroustrup在内，Stepanove又对STL进行了改进。同时加入了一个封装内存模式信息的抽象模块，也就是现在STL中的allocator，它使STL的大部分实现都可以独立于具体的内存模式，从而独立于具体平台。在同年夏季的滑铁卢会议上，委员们以80%赞成，20%反对，最终通过了提案，决定将STL正式纳入C++标准化进程之中，随后STL便被放进了会议的工作文件中。自此，STL终于成为了C++家族中的重要一员。 此后，随着C++标准的不断改进，STL也在不断地作着相应的演化。直至1998年，ANSI/ISO C++标准正式定案，STL始终是C++标准中不可或缺的一大部件。 1.3 千丝万缕的联系在你了解了STL的过去之后，一些名词开始不断在你的大脑中浮现，STL、C++、C++标准函数库、泛型程序设计、面向对象程序设计……，这些概念意味着什么？他们之间的关系又是什么？如果你想了解某些细节，这里也许有你希望得到的答案。 1.3.1 STL和C++没有C++语言就没有STL，这么说毫不为过。一般而言，STL作为一个泛型化的数据结构和算法库，并不牵涉具体语言（当然，在C++里，它被称为STL）。也就是说，如果条件允许，用其他语言也可以实现之。这里所说的条件，主要是指类似于”模板”这样的语法机制。如果你没有略过前一节内容的话，应该可以看到，Alexander Stepanov在选择C++语言作为实现工具之前，早以采用过多种程序设计语言。但是，为什么最终还是C++幸运的承担了这个历史性任务呢？原因不仅在于前述那个条件，还在于C++在某些方面所表现出来的优越特性，比如：高效而灵活的指针。但是如果把C++作为一种OOP（Object-Oriented Programming，面向对象程序设计）语言来看待的话（事实上我们一般都是这么认为的，不是吗？），其功能强大的继承机制却没有给STL的实现帮上多大的忙。在STL的源代码里，并没有太多太复杂的继承关系。继承的思想，甚而面向对象的思想，还不足以实现类似STL这样的泛型库。C++只有在引入了”模板”之后，才直接导致了STL的诞生。这也正是为什么，用其他比C++更纯的面向对象语言无法实现泛型思想的一个重要原因。当然，事情总是在变化之中，像Java在这方面，就是一个很好的例子，jdk1.4中已经加入了泛型的特性。 此外，STL对于C++的发展，尤其是模板机制，也起到了促进作用。比如：模板函数的偏特化（template function partial specialization），它被用于在特定应用场合，为一般模板函数提供一系列特殊化版本。这一特性是继STL被ANSI/ISO C++标准委员会通过之后，在Bjarne和Stepanov共同商讨之下并由Bjarne向委员会提出建议的，最终该项建议被通过。这使得STL中的一些算法在处理特殊情形时可以选择非一般化的方式，从而保证了执行的效率。 1.3.2 STL和C++标准函数库STL是最新的C++标准函数库中的一个子集，这个庞大的子集占据了整个库的大约80%的分量。而作为在实现STL过程中扮演关键角色的模板则充斥了几乎整个C++标准函数库。在这里，我们有必要看一看C++标准函数库里包含了哪些内容，其中又有哪些是属于标准模板库（即STL）的。 C++标准函数库为C++程序员们提供了一个可扩展的基础性框架。我们从中可以获得极大的便利，同时也可以通过继承现有类，自己编制符合接口规范的容器、算法、迭代子等方式对之进行扩展。它大致包含了如下几个组件：C标准函数库，基本保持了与原有C语言程序库的良好兼容，尽管有些微变化。人们总会忍不住留恋过去的美好岁月，如果你曾经是一个C程序员，对这一点一定体会颇深。或许有一点会让你觉得奇怪，那就是在C++标准库中存在两套C的函数库，一套是带有.h扩展名的，比如stdio.h，而另一套则没有，比如cstdio。它们确实没有太大的不同。 语言支持（language support）部分，包含了一些标准类型的定义以及其他特性的定义，这些内容，被用于标准库的其他地方或是具体的应用程序中。诊断（diagnostics）部分，提供了用于程序诊断和报错的功能，包含了异常处理（exception handling），断言（assertions），错误代码（error number codes）三种方式。 通用工具（general utilities）部分，这部分内容为C++标准库的其他部分提供支持，当然你也可以在自己的程序中调用相应功能。比如：动态内存管理工具，日期/时间处理工具。记住，这里的内容也已经被泛化了（即采用了模板机制）。字符串（string）部分，用来代表和处理文本。它提供了足够丰富的功能。事实上，文本是一个string对象，它可以被看作是一个字符序列，字符类型可能是char，或者wchar_t等等。string可以被转换成char类型，这样便可以和以前所写的C/C++代码和平共处了。因为那时侯除了char，没有别的。 国际化（internationalization）部分，作为OOP特性之一的封装机制在这里扮演着消除文化和地域差异的角色，采用locale和facet可以为程序提供众多国际化支持，包括对各种字符集的支持，日期和时间的表示，数值和货币的处理等等。毕竟，在中国和在美国，人们表示日期的习惯是不同的。 容器（containers）部分，STL的一个重要组成部分，涵盖了许多数据结构，比如前面曾经提到的链表，还有：vector（类似于大小可动态增加的数组）、queue（队列）、stack（堆栈）……。string也可以看作是一个容器，适用于容器的方法同样也适用于string。现在你可以轻松的完成数据结构课程的家庭作业了。 算法（algorithms）部分，STL的一个重要组成部分，包含了大约70个通用算法，用于操控各种容器，同时也可以操控内建数组。比如：find用于在容器中查找等于某个特定值的元素，for_each用于将某个函数应用到容器中的各个元素上，sort用于对容器中的元素排序。所有这些操作都是在保证执行效率的前提下进行的，所以，如果在你使用了这些算法之后程序变得效率底下，首先一定不要怀疑这些算法本身，仔细检查一下程序的其他地方。 迭代器（iterators）部分，STL的一个重要组成部分，如果没有迭代器的撮合，容器和算法便无法结合的如此完美。事实上，每个容器都有自己的迭代器，只有容器自己才知道如何访问自己的元素。它有点像指针，算法通过迭代器来定位和操控容器中的元素。 数值（numerics）部分，包含了一些数学运算功能，提供了复数运算的支持。输入/输出（input/output）部分，就是经过模板化了的原有标准库中的iostream部分，它提供了对C++程序输入输出的基本支持。在功能上保持了与原有iostream的兼容，并且增加了异常处理的机制，并支持国际化（internationalization）。总体上，在C++标准函数库中，STL主要包含了容器、算法、迭代器。string也可以算做是STL的一部分。 1.3.3 STL和GP，GP和OOP正如前面所提到的，在STL的背后蕴含着泛型化程序设计（GP）的思想，在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。这一思想和面向对象的程序设计思想（OOP）不尽相同，因为，在OOP中更注重的是对数据的抽象，即所谓抽象数据类型（Abstract Data Type），而算法则通常被附属于数据类型之中。几乎所有的事情都可以被看作类或者对象（即类的实例），通常，我们所看到的算法被作为成员函数（member function）包含在类（class）中，类和类则构成了错综复杂的继承体系。 尽管在象C++这样的程序设计语言中，你还可以用全局函数来表示算法，但是在类似于Java这样的纯面向对象的语言中，全局函数已经被”勒令禁止”了。因此，用Java来模拟GP思想是颇为困难的。如果你对前述的STL历史还有印象的话，应该记得Alexander Stepanove也曾用基于OOP的语言尝试过实现GP思想，但是效果并不好，包括没有引入模板之前的C++语言。站在巨人的肩膀上，我们可以得出这样的结论，在OOP中所体现的思想与GP的思想确实是相异的。C++并不是一种纯面向对象的程序设计语言，它的绝妙之处，就在于既满足了OOP，又成全了GP。对于后者，模板立下了汗马功劳。另外，需要指出的是，尽管GP和OOP有诸多不同，但这种不同还不至于到”水火不容”的地步。并且，在实际运用的时候，两者的结合使用往往可以使问题的解决更为有效。作为GP思想实例的STL本身便是一个很好的范例，如果没有继承，不知道STL会是什么样子，似乎没有人做过这样的试验。 1.4 STL的不同实现版本相信你对STL的感性认识应该有所提高了，是该做一些实际的工作了，那么我们首先来了解一下STL的不同实现版本。ANSI/ISO C++文件中的STL是一个仅被描述在纸上的标准，对于诸多C++编译器而言，需要有各自实际的STL，它们或多或少的实现了标准中所描述的内容，这样才能够为我们所用。之所以有不同的实现版本，则存在诸多原因，有历史的原因，也有各自编译器生产厂商的原因。以下是几个常见的STL实现版本。 1.4.1 HP STLHP STL是所有其它STL实现版本的根源。它是STL之父Alexander Stepanov在惠普的Palo Alto实验室工作时，和Meng Lee共同完成的，是第一个STL的实现版本（参见1.2节）。这个STL是开放源码的，所以它允许任何人免费使用、复制、修改、发布和销售该软件和相关文档，前提是必须在所有相关文件中加入HP STL的版本信息和授权信息。现在已经很少直接使用这个版本的STL了。 1.4.2 P.J. Plauger STLP. J. Plauger STL属于个人作品，由P. J. Plauger本人实现，是HP STL的一个继承版本，因此在其所有头文件中都含有HP STL的相关声明，同时还有P. J. Plauger本人的版权声明。P. J. Plauger是标准C中stdio库的早期实现者，现在是C/C++ User’s Journal的主编，与Microsoft保持着良好的关系。P. J. Plauger STL便是被用于Microsoft的Visual C++中的。在Windows平台下的同类版本中，其性能不错，但是queue组件（队列，一种容器）的效率不理想，同时由于Visual C++对C++语言标准的支持不是很好（至少直到VC6.0为止，还是如此），因此一定程度上影响了P. J. Plauger STL的性能。此外，该版本的源代码可读性较差，你可以在VC的Include子目录下找到所有源文件（比如：C:\Program Files\Microsoft Visual Studio\VC98\Include）。因为不是开放源码的（open source），所以这些源代码是不能修改和销售的，目前P.J. Plauger STL由Dinkumware公司提供相关服务，详情请见http://www.dinkumware.com。据称Visual Studio.NET中的Visual C++.NET（即VC7.0），对C++标准的支持有所提高，并且多了以哈希表（hash table）为基础而实现的map容器，multimap容器和set容器。 1.4.3 Rouge Wave STLRouge Wave STL是由Rouge Wave公司实现的，也是HP STL的一个继承版本，除了HP STL的相关声明之外，还有Rouge Wave公司的版权声明。同时，它也不是开放源码的，因此无法修改和销售。该版本被Borland C++ Builder所采用，你可以在C++ Builder的Include子目录下找到所有头文件（比如：C:\Program Files\Borland\Cbuilder5\Include）。尽管Rouge Wave STL的性能不是很好，但由于C++ Builder对C++语言标准的支持还算不错，使其表现在一定程度上得以改善。此外，其源代码的可读性较好。可以从如下网站得到更详细的情况介绍：http://www.rougewave.com。遗憾的是该版本已有一段时间没有更新且不完全符合标准。因此在Borland C++ Builder 6.0中，它的地位被另一个STL的实现版本–STLport（见后）取代了。但是考虑到与以前版本的兼容，C++ Builder 6.0还是保留了Rouge Wave STL，只是如果你想查看它的源代码的话，需要在别的目录中才能找到（比如：C:\Program Files\Borland\Cbuilder6\Include\oldstl）。 1.4.4 STLportSTLport最初源于俄国人Boris Fomitchev的一个开发项目，主要用于将SGI STL的基本代码移植到其他诸如C++Builder或者是Visual C++这样的主流编译器上。因为SGI STL属于开放源码，所以STLport才有权这样做。目前STLport的最新版本是4.5。可以从如下网站得到更详细的情况介绍：http://www.stlport.org，可以免费下载其源代码。STLport已经被C/C++技术委员会接受成为工业标准，且在许多平台上都支持。根据测试STLport的效率比VC中的STL要快。比Rouge Wave STL更符合标准，也更容易移植。Borland C++ Builder已经在其6.0版中加入了对STLport的支持，它使用的STLport就是4.5版的，C++ Builder 6.0同时还提供了STLport的使用说明。你可以在C++ Builder的Include\Stlport子目录下找到所有头文件（比如：C:\Program Files\Borland\Cbuilder6\Include\Stlport）。 1.4.5 SGI STLSGI STL是由Silicon Graphics Computer System, Inc公司实现的，其设计者和编写者包括Alexander Stepanov和Matt Austern，同样它也是HP STL的一个继承版本。它属于开放源码，因此你可以修改和销售它。SGI STL被GCC（linux下的C++编译器）所采用，你可以在GCC的Include子目录下找到所有头文件（比如：C:\cygnus\cygwin-b20\include\g++\include）。由于GCC对C++语言标准的支持很好，SGI STL在linux平台上的性能相当出色。此外，其源代码的可读性也很好。可以从如下网站得到更详细的情况介绍：http://www.sgi.com，可以免费下载其源代码。目前的最新版本是3.3。 2 牛刀小试：且看一个简单例程2.1 引子如果你是一个纯粹的实用主义者，也许一开始就可以从这里开始看起，因为此处提供了一个示例程序，它可以带给你有关使用STL的最直接的感受。是的，与其纸上谈兵，不如单刀直入，实际操作一番。但是，需要提醒的是，假如你在兴致昂然地细细品味本章内容的时候，能够同时结合前面章节作为佐餐，那将是再好不过的。你会发现，前面所提到的有关STL的那些优点，在此处得到了确切的应证。本章的后半部分，将为你演示在一些主流C++编译器上，运行上述示例程序的具体操作方法，和需要注意的事项。 2.2 例程实作非常遗憾，我不得不舍弃”Hello World”这个经典的范例，尽管它不只一次的被各种介绍计算机语言的教科书所引用，几乎成为了一个默认的“标准”。其原因在于它太过简单了，以至于不具备代表性，无法展现STL的巨大魅力。我选用了一个稍稍复杂一点的例子，它的大致功能是：从标准输入设备（一般是键盘）读入一些整型数据，然后对它们进行排序，最终将结果输出到标准输出设备（一般是显示器屏幕）。这是一种典型的处理方式，程序本身具备了一个系统所应该具有的几乎所有的基本特征：输入 + 处理 + 输出。你将会看到三个不同版本的程序。第一个是没有使用STL的普通C++程序，你将会看到完成这样看似简单的事情，需要花多大的力气，而且还未必没有一点问题（真是吃力不讨好）。第二个程序的主体部分使用了STL特性，此时在第一个程序中所遇到的问题就基本可以解决了。同时，你会发现采用了STL之后，程序变得简洁明快，清晰易读。第三个程序则将STL的功能发挥到了及至，你可以看到程序里几乎每一行代码都是和STL相关的。这样的机会并不总是随处可见的，它展现了STL中的几乎所有的基本组成部分，尽管这看起来似乎有点过分了。有几点是需要说明的：这个例程的目的，在于向你演示如何在C++程序中使用STL，同时希望通过实践，证明STL所带给你的确确实实的好处。程序中用到的一些STL基本组件，比如：vector（一种容器）、sort（一种排序算法），你只需要有一个大致的概念就可以了，这并不影响阅读代码和理解程序的含义。 很多人对GUI（图形用户界面）的运行方式很感兴趣，这也难怪，漂亮的界面总是会令人赏心悦目的。但是很可惜，在这里没有加入这些功能。这很容易解释，对于所提供的这个简单示例程序而言，加入GUI特性，是有点本末倒置的。这将会使程序的代码量骤然间急剧膨胀，而真正可以说明问题的核心部分确被淹没在诸多无关紧要的代码中间（你需要花去极大的精力来处理键盘或者鼠标的消息响应这些繁琐而又较为规范的事情）。即使你有像Borland C++ Builder这样的基于IDE（集成化开发环境）的工具，界面的处理变得较为简单了（框架代码是自动生成的）。请注意，我们这里所谈及的是属于C++标准的一部分（STL的第一个字母说明了这一点），它不涉及具体的某个开发工具，它是几乎在任何C++编译器上都能编译通过的代码。毕竟，在Microsoft Visual C++和Borland C++ Builder里，有关GUI的处理代码是不一样的。如果你想了解这些GUI的细节，这里恐怕没有你希望得到的答案，你可以寻找其它相关书籍。 2.2.1 第一版：史前时代–转木取火在STL还没有降生的”黑暗时代”，C++程序员要完成前面所提到的那些功能，需要做很多事情（不过这比起C程序来，似乎好一点），程序大致是如下这个样子的： 1234567891011121314151617181920212223242526272829303132333435// name:example2_1.cpp// alias:Rubish#include &lt;stdlib.h&gt;#include &lt;iostream.h&gt;int compare(const void *arg1, const void *arg2);void main(void)&#123; const int max_size = 10; // 数组允许元素的最大个数 int num[max_size]; // 整型数组 // 从标准输入设备读入整数，同时累计输入个数， // 直到输入的是非整型数据为止 int n; for (n = 0; cin &gt;&gt; num[n]; n ++); // C标准库中的快速排序（quick-sort）函数 qsort(num, n, sizeof(int), compare); // 将排序结果输出到标准输出设备 for (int i = 0; i &lt; n; i ++) cout &lt;&lt; num[i] &lt;&lt; "\n";&#125;// 比较两个数的大小，// 如果*(int *)arg1比*(int *)arg2小，则返回-1// 如果*(int *)arg1比*(int *)arg2大，则返回1// 如果*(int *)arg1等于*(int *)arg2，则返回0int compare(const void *arg1, const void *arg2)&#123; return (*(int *)arg1 &lt; *(int *)arg2) ? -1 : (*(int *)arg1 &gt; *(int *)arg2) ? 1 : 0;&#125; 这是一个和STL没有丝毫关系的传统风格的C++程序。因为程序的注释已经很详尽了，所以不需要我再做更多的解释。总的说来，这个程序看起来并不十分复杂（本来就没有太多功能）。只是，那个compare函数，看起来有点费劲。指向它的函数指针被作为最后一个实参传入qsort函数，qsort是C程序库stdlib.h中的一个函数。以下是qsort的函数原型： 12345678910111213141516171819202122void qsort(void *base, size_t num, size_t width, int (__cdecl *compare )(const void *elem1, const void *elem2 ) );``` 看起来有点令人作呕，尤其是最后一个参数。大概的意思是，第一个参数指明了要排序的数组（比如：程序中的num），第二个参数给出了数组的大小（qsort没有足够的智力预知你传给它的数组的实际大小），第三个参数给出了数组中每个元素以字节为单位的大小。最后那个长长的家伙，给出了排序时比较元素的方式（还是因为qsort的智商问题）。以下是某次运行的结果： 输入：0 9 2 1 5输出：0 1 2 5 9 有一个问题，这个程序并不像看起来那么健壮（Robust）。如果我们输入的数字个数超过max_size所规定的上限，就会出现数组越界问题。如果你在Visual C++的IDE环境下以控制台方式运行这个程序时，会弹出非法内存访问的错误对话框。这个问题很严重，严重到足以使你开始重新审视这个程序的代码。为了弥补程序中的这一缺陷。我们不得不考虑采用如下三种方案中的一种：采用大容量的静态数组分配。 限定输入的数据个数。 采用动态内存分配。 第一种方案比较简单，你所做的只是将max_size改大一点，比如：1000或者10000。但是，严格讲这并不能最终解决问题，隐患仍然存在。假如有人足够耐心，还是可以使你的这个经过纠正后的程序崩溃的。此外，分配一个大数组，通常是在浪费空间，因为大多数情况下，数组中的一部分空间并没有被利用。再来看看第二种方案，通过在第一个for循环中加入一个限定条件，可以使问题得到解决。比如：for (int n = 0; cin &gt;&gt; num[n] &amp;&amp; n &lt; max_size; n ++); 但是这个方案同样不甚理想，尽管不会使程序崩溃，但失去了灵活性，你无法输入更多的数。看来只有选择第三种方案了。是的，你可以利用指针，以及动态内存分配妥善的解决上述问题，并且使程序具有良好的灵活性。这需要用到new，delete操作符，或者古老的malloc()，realloc()和free()函数。但是为此，你将牺牲程序的简洁性，使程序代码陡增，代码的处理逻辑也不再像原先看起来那么清晰了。一个compare函数或许就已经令你不耐烦了，更何况要实现这些复杂的处理机制呢？很难保证你不会在处理这个问题的时候出错，很多程序的bug往往就是这样产生的。同时，你还应该感谢stdlib.h，它为你提供了qsort函数，否则，你还需要自己实现排序算法。如果你用的是冒泡法排序，那效率就不会很理想。……，问题真是越来越让人头疼了！关于第一个程序的讨论就到此为止，如果你对第三种方案感兴趣的话，可以尝试着自己编写一个程序，作为思考题。这里就不准备再浪费笔墨去实现这样一个让人不甚愉快的程序了。#### 2.2.2 第二版：工业时代--组件化大生产我们应该庆幸自己所生活的年代。工业时代，科技的发展所带来的巨大便利已经影响到了我们生活中的每个细节。如果你还在以原始人类的方式生活着，那我真该怀疑你是否属于某个生活在非洲或者南美丛林里的原始部落中的一员了，难道是玛雅文明又重现了？STL便是这个时代的产物，正如其他科技成果一样，C++程序员也应该努力使自己适应并充分利用这个"高科技成果"。让我们重新审视第一版的那个破烂不堪的程序。试着使用一下STL，看看效果如何。 // name:example2_2.cpp// alias:The first STL program #include #include #include using namespace std; void main(void){ vector num; // STL中的vector容器 int element; // 从标准输入设备读入整数， // 直到输入的是非整型数据为止 while (cin &gt;&gt; element) num.push_back(element); // STL中的排序算法 sort(num.begin(), num.end()); // 将排序结果输出到标准输出设备 for (int i = 0; i &lt; num.size(); i ++) cout &lt;&lt; num[i] &lt;&lt; &quot;\n&quot;; }123456789101112131415这个程序的主要部分改用了STL的部件，看起来要比第一个程序简洁一点，你已经找不到那个讨厌的compare函数了。它真的能很好的运行吗？你可以试试，因为程序的运行结果和前面的大致差不多，所以在此略去。我可以向你保证，这个程序是足够健壮的。不过，可能你还没有完全看明白程序的代码，所以我需要为你解释一下。毕竟，这个戏法变得太快了，较之第一个程序，一眨眼的功夫，那些老的C++程序员所熟悉的代码都不见了，取而代之的是一些新鲜玩意儿。程序的前三行是包含的头文件，它们提供了程序所要用到的所有C++特性（包括输入输出处理，STL中的容器和算法）。不必在意那个.h，并不是我的疏忽，程序保证可以编译通过，只要你的C++编译器支持标准C++规范的相关部分。你只需要把它们看作是一些普通的C++头文件就可以了。事实上，也正是如此，如果你对这个变化细节感兴趣的化，可以留意一下你身旁的佐餐。同样可以忽略第四行的存在。加入那个声明只是为了表明程序引用到了std这个标准名字空间（namespace），因为STL中的那些玩意儿全都包含在那里面。只有通过这行声明，编译器才能允许你使用那些有趣的特性。程序中用到了vector，它是STL中的一个标准容器，可以用来存放一些元素。你可以把vector理解为int [?]，一个整型的数组。之所以大小未知是因为，vector是一个可以动态调整大小的容器，当容器已满时，如果再放入元素则vector会悄悄扩大自己的容量。push_back是vector容器的一个类属成员函数，用来在容器尾端插入一个元素。main函数中第一个while循环做的事情就是不断向vector容器尾端插入整型数据，同时自动维护容器空间的大小。sort是STL中的标准算法，用来对容器中的元素进行排序。它需要两个参数用来决定容器中哪个范围内的元素可以用来排序。这里用到了vector的另两个类属成员函数。begin()用以指向vector的首端，而end()则指向vector的末端。这里有两个问题，begin()和end()的返回值是什么？这涉及到STL的另一个重要部件--迭代器（Iterator），不过这里并不需要对它做详细了解。你只需要把它当作是一个指针就可以了，一个指向整型数据的指针。相应的sort函数声明也可以看作是void sort(int* first, int* last)，尽管这实际上很不精确。另一个问题是和end()函数有关，尽管前面说它的返回值指向vector的末端，但这种说法不能算正确。事实上，它的返回值所指向的是vector中最末端元素的后面一个位置，即所谓pass-the-end value。这听起来有点费解，不过不必在意，这里只是稍带一提。总的来说，sort函数所做的事情是对那个准整型数组中的元素进行排序，一如第一个程序中的那个qsort，不过比起qsort来，sort似乎要简单了许多。程序的最后是输出部分，在这里vector完全可以以假乱真了，它所提供的对元素的访问方式简直和普通的C++内建数组一模一样。那个size函数用来返回vector中的元素个数，就相当于第一个程序中的变量n。这两行代码直观的不用我再多解释了。我想我的耐心讲解应该可以使你大致看懂上面的程序了，事实上STL的运用使程序的逻辑更加清晰，使代码更易于阅读。试问，有谁会不明白begin、end、size这样的字眼所表达的含义呢（除非他不懂英语）？试着运行一下，看看效果。再试着多输入几个数，看看是否会发生数组越界现象。实践证明，程序运行良好。是的，由于vector容器自行维护了自身的大小，C++程序员就不用操心动态内存分配了，指针的错误使用毕竟会带来很多麻烦，同时程序也会变得冗长无比。这正是前面第三种方案的缺点所在。再仔细审视一下你的第一个STL版的C++程序，回顾一下第一章所提到的那些有关STL的优点：易于使用，具有工业强度……，再比较一下第一版的程序，我想你应该有所体会了吧！#### 2.2.3 第三版：唯美主义的杰作事态的发展有时候总会趋向极端，这在那些唯美主义者当中犹是如此。首先声明，我并不是一个唯美主义者，提供第二版程序的改进版，完全是为了让你更深刻的感受到STL的魅力所在。在看完第三版之后，你会强烈感受到这一点。或许你也会变成一个唯美主义者了，至少在STL方面。这应该不是我的错，因为决定权在你手里。下面我们来看看这个绝版的C++程序。 // name:example2_3.cpp// alias:aesthetic version #include #include #include #include using namespace std; void main(void){ typedef vector int_vector; typedef istream_iterator istream_itr; typedef ostream_iterator ostream_itr; typedef back_insert_iterator&lt; int_vector &gt; back_ins_itr; // STL中的vector容器 int_vector num; // 从标准输入设备读入整数， // 直到输入的是非整型数据为止 copy(istream_itr(cin), istream_itr(), back_ins_itr(num)); // STL中的排序算法 sort(num.begin(), num.end()); // 将排序结果输出到标准输出设备 copy(num.begin(), num.end(), ostream_itr(cout, &quot;\n&quot;)); }1234567在这个程序里几乎每行代码都是和STL有关的（除了main和那对花括号，当然还有注释），并且它包含了STL中几乎所有的各大部件（容器container，迭代器iterator, 算法algorithm, 适配器adaptor），唯一的遗憾是少了函数对象（functor）的身影。还记得开头提到的一个典型系统所具有的基本特征吗？--输入+处理+输出。所有这些功能，在上面的程序里，仅仅是通过三行语句来实现的，其中每一行语句对应一种操作。对于数据的操作被高度的抽象化了，而算法和容器之间的组合，就像搭积木一样轻松自如，系统的耦合度被降到了极低点。这就是闪耀着泛型之光的STL的伟大力量。如此简洁，如此巧妙，如此神奇！就像魔术一般，以至于再一次让你摸不着头脑。怎么实现的？为什么在看第二版程序的时候如此清晰的你，又坠入了五里雾中（窃喜）。请留意此处的标题（唯美主义的杰作），在实际环境中，你未必要做到这样完美。毕竟美好愿望的破灭，在生活中时常会发生。过于理想化，并不是一件好事，至少我是这么认为的。正如前面提到的，这个程序只是为了展示STL的独特魅力，你不得不为它的出色表现所折服，也许只有深谙STL之道的人才会想出这样的玩意儿来。如果你只是一般性的使用STL，做到第二版这样的程度也就可以了。实在是因为这个程序太过"简单"，以至于我无法肯定，在你还没有完全掌握STL之前，通过我的讲解，是否能够领会这区区三行代码，我将尽我的最大努力。前面提到的迭代器可以对容器内的任意元素进行定位和访问。在STL里，这种特性被加以推广了。一个cin代表了来自输入设备的一段数据流，从概念上讲它对数据流的访问功能类似于一般意义上的迭代器，但是C++中的cin在很多地方操作起来并不像是一个迭代器，原因就在于其接口和迭代器的接口不一致（比如：不能对cin进行++运算，也不能对之进行取值运算--即*运算）。为了解决这个矛盾，就需要引入适配器的概念。istream_iterator便是一个适配器，它将cin进行包装，使之看起来像是一个普通的迭代器，这样我们就可以将之作为实参传给一些算法了（比如这里的copy算法）。因为算法只认得迭代器，而不会接受cin。对于上面程序中的第一个copy函数而言，其第一个参数展开后的形式是：istream_iterator(cin)，其第二个参数展开后的形式是：istream_iterator()（如果你对typedef的语法不清楚，可以参考有关的c++语言书籍）。其效果是产生两个迭代器的临时对象，前一个指向整型输入数据流的开始，后一个则指向"pass-the-end value"。这个函数的作用就是将整型输入数据流从头至尾逐一"拷贝"到vector这个准整型数组里，第一个迭代器从开始位置每次累进，最后到达第二个迭代器所指向的位置。或许你要问，如果那个copy函数的行为真如我所说的那样，为什么不写成如下这个样子呢？ copy(istream_iterator(cin), istream_iterator(), num.begin());`你确实可以这么做，但是有一个小小的麻烦。还记得第一版程序里的那个数组越界问题吗？如果你这么写的话，就会遇到类似的麻烦。原因在于copy函数在”拷贝”数据的时候，如果输入的数据个数超过了vector容器的范围时，数据将会拷贝到容器的外面。此时，容器不会自动增长容量，因为这只是简单地拷贝，并不是从末端插入。为了解决这个问题，另一个适配器back_insert_iterator登场了，它的作用就是引导copy算法每次在容器末端插入一个数据。程序中的那个back_ins_itr(num)展开后就是：back_insert_iterator(num)，其效果是生成一个这样的迭待器对象。终于将讲完了三分之一（真不容易！），好在第二句和前一版程序没有差别，这里就略过了。至于第三句，ostream_itr(cout, “\n”)展开后的形式是：ostream_iterator(cout, “\n”)，其效果是产生一个处理输出数据流的迭待器对象，其位置指向数据流的起始处，并且以”\n”作为分割符。第二个copy函数将会从头至尾将vector中的内容”拷贝”到输出设备，第一个参数所代表的迭代器将会从开始位置每次累进，最后到达第二个参数所代表的迭代器所指向的位置。这就是全部的内容。 2.3 历史的评价历史的车轮总是滚滚向前的，工业时代的文明较之史前时代，当然是先进并且发达的。回顾那两个时代的C++程序，你会真切的感受到这种差别。简洁易用，具有工业强度，较好的可移植性，高效率，加之第三个令人目眩的绝版程序所体现出来的高度抽象性，高度灵活性和组件化特性，使你对STL背后所蕴含的泛型化思想都有了些微的感受。真幸运，你可以横跨两个时代，有机会目睹这种”文明”的差异。同时，这也应该使你越加坚定信念，使自己顺应时代的潮流。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa--10082--WERTYU]]></title>
    <url>%2F2018%2F01%2F03%2FUVa--10082--WERTYU%2F</url>
    <content type="text"><![CDATA[题目这个题目运用到了常量数组，然后需要进行简单字符匹配输出，值得注意的是对于‘\’转义符的处理，‘\’两次才能表示‘\’转义符。代码如下：1234567891011121314151617#include&lt;stdio.h&gt;char c[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";int main()&#123; char s; while((s=getchar())!=EOF) &#123; int i=1; while(c[i] &amp;&amp; c[i]!=s) i++; if(c[i]) putchar(c[i-1]); else putchar(s); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa--272--TEX Quotes]]></title>
    <url>%2F2018%2F01%2F03%2FUVa--272--TEX%20Quotes%2F</url>
    <content type="text"><![CDATA[题目题目的关键所在就是如何判断双引号是左双引号还是右双引号，我们易知引号是成对存在的，所以我们用一个标记变量就可以的判断了。其次便是输入问题，我们知道scanf输入遇到空格便会停下，所以我们会用到getchar函数代码如下： 123456789101112131415#include&lt;stdio.h&gt; int main() &#123; int s,n = 1; while((s = getchar()) != EOF) &#123; if(s == '"') &#123; printf("%s", n ? "``" : "''"); n = !n; &#125; else printf("%c", s); &#125; return 0; &#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces--477Div.2--B]]></title>
    <url>%2F2017%2F11%2F27%2FCodeforces--477Div.2--B%2F</url>
    <content type="text"><![CDATA[题目 这个题目是个思维题，同时包含着快速幂运算，规律找出来后用个快速幂的板子很好AC 题意：题目给出m x n的网格，要求每行每列相乘都是等于1或者-1可以很快得出每个格子只能填-1或者1（题目中要求是整数），那么我们也可以知道的是，每一行每一列的乘积应该是取决于最后一个填入网格的数字，假设一列中有n个数字，那么前n-1个数字是随意填1或者-1的，第n个数字就必须为一个定值。初步可以得出的结论是：方法的种类有2^（m-1）* （n-1）种。 但题目的坑点不在此！ 我们必须注意的是当m+n为奇数，k=-1时必然导致有一行或者一列出现两个-1，所以这种情况是不存在的，此时应该输出0。 AC代码： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;typedef long long LL;const int M=1000000007;LL quickmi(LL a,LL b)&#123; LL ans =1,vis=a ; while(b) &#123; if(b&amp;1) ans=(vis%M*ans%M)%M; \\一开始没注意取模，干脆...我都取了模 vis=((vis%M)*(vis%M))%M; b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; LL m,n,k; scanf("%I64d%I64d%I64d",&amp;m,&amp;n,&amp;k); if(k==-1&amp;&amp;((m+n)%2)==1) &#123; printf("0\n"); &#125; else &#123; LL anser=quickmi(2,n-1); //值得注意的是，m，n的范围最大到10^18 anser=quickmi(anser,m-1); //所以相乘会爆掉long long 所以进行了两次操作 printf("%I64d",anser); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces--477Div.2--A]]></title>
    <url>%2F2017%2F11%2F22%2FCodeforces--447Div.2--A%2F</url>
    <content type="text"><![CDATA[题目 给出一串字符，题目要求输出有多少个QAQ，不限制中间穿插了多少个字符，不同的QAQ可以使用同一个Q或者A。由于数据量较少，我是暴力遍历出来的，贼菜代码如下： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;char a[105];int main()&#123; int count=0; scanf("%s",a); int len=strlen(a); for(int i=0;i&lt;len;i++) &#123; if(a[i]=='Q') &#123; for(int j=i+1;j&lt;len;j++) &#123; if(a[j]=='A') &#123; for(int k=j;k&lt;len;k++) &#123; if(a[k]=='Q') count++; &#125; &#125; &#125; &#125; &#125; printf("%d\n",count); return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ--3176--Cow Bowling]]></title>
    <url>%2F2017%2F11%2F22%2FPOJ--3176--Cow%20Bowling%2F</url>
    <content type="text"><![CDATA[题目 点开这里有详解 之前整理过就不整理了，哈哈哈嗝]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ--3992--One-Dimensional Maze]]></title>
    <url>%2F2017%2F11%2F22%2FZOJ--3992--One-Dimensional%20Maze%2F</url>
    <content type="text"><![CDATA[题目题意：给出一串只有RL的字符串，给定起始位置，R表示向右，L表示向左，现在要求输出最少改变几个字符可以移动到字符第一个或者最后一个。例如：6 3LLRRLR起始位置是第三个字符R，只用改变第三个R就可以到达第一个字符L 这道题目通过模拟就可以做出来，就是将到达两边要改变的字符都求出来，输出最小的那个见代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;using namespace std;#define maxn 100005char a[maxn];int main()&#123; int T; scanf("%d",&amp;T); int n,m; while(T--) &#123; int count1=0,count2=1; //如果是去与起始字符相反的方向则需要算上起始位置的改变 scanf("%d%d",&amp;n,&amp;m); scanf("%s",a); if(a[m-1]=='R') &#123; for(int i=m;i&lt;n-1;i++) //从末尾向起始位置遍历 &#123; if(a[i]=='L') //遇见L就变为R，count1++ count1++; &#125; for(int i=1;i&lt;m-1;i++) //从开头到起始位置遍历 &#123; if(a[i]=='R') //遇见R变成L，count2++ &#123; count2++; //由于起始位置是R所以到左边需要改变自身，所以为count2 &#125; &#125; &#125; else //同理于起始位置为R &#123; for(int i=m;i&lt;n-1;i++) &#123; if(a[i]=='L') count2++; &#125; for(int i=1;i&lt;m-1;i++) &#123; if(a[i]=='R') count1++; &#125; &#125; if(count1&lt;count2) printf("%d\n",count1); else printf("%d\n",count2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU--4221--Greedy?]]></title>
    <url>%2F2017%2F11%2F22%2FHDU--4221--Greedy_%2F</url>
    <content type="text"><![CDATA[题目这个题目题意有点容易理解错，理解了后就比较简单了。 题目要求的是求出总罚值最小的情况下最大的罚值要让总罚值最小，将最小期限Di排序，然后将最大的罚值求出来就可以了。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Time //定义Di ， Ci 的结构体，方便排序操作&#123; int Ci; int Di;&#125;;bool cmp(Time a,Time b) //定义比较函数&#123; return a.Di&lt;b.Di;&#125;Time a[100005];int main()&#123; int T,ca=0; scanf("%d",&amp;T); while(T--) &#123; ca++; int n; long long sum=0,ans=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%d%d",&amp;a[i].Ci,&amp;a[i].Di); &#125; sort(a,a+n,cmp); //快速排序 for(int i=0;i&lt;n;i++) &#123; ans+=a[i].Ci; if(ans-a[i].Di&gt;sum) sum=ans-a[i].Di; &#125; printf("Case %d: %lld\n",ca,sum); &#125;&#125; 题目还是比较简单的，运用的就只有对结构体进行排序知识点，不是很难。]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU--6063--RXD and math]]></title>
    <url>%2F2017%2F11%2F19%2FHDU--6063--RXD%20and%20math%2F</url>
    <content type="text"><![CDATA[题目题解：题目运用的是快速幂，主要是要找到规律，规律的出的是：输出n^k即可（可以自己带入数字尝试一下） 所以很题目很简单处理，套一个快速幂的模板就可以了 但是要注意的有两点：1.对数取模 （实在不行，把进行处理的数都取模吧…）2.注意数据范围（同上，直接都 long long吧…） 代码如下：1234567891011121314151617181920212223242526#include&lt;cstdio&gt;const int M=1e9+7;long long fun(long long a,long long b,int k)&#123; long long ans=1; while(b&gt;0) &#123; a=a%k; if(b&amp;1) ans=((ans%k)*(a%k))%k; b/=2; a=(a%k*a%k)%k; &#125; return ans%k;&#125;int main()&#123; long long n,k; int ca=0; while((scanf("%lld%lld",&amp;n,&amp;k)!=EOF)) &#123; ca++; printf("Case #%d: %lld\n",ca,fun(n,k,M)); &#125; return 0;&#125; 如果不了解快速幂可以点文章开头的链接。]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Hdu</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces--839A--Arya and Bran]]></title>
    <url>%2F2017%2F11%2F07%2FCodeforces--839A--Arya%20and%20Bran%2F</url>
    <content type="text"><![CDATA[题目Bran and his older sister Arya are from the same house. Bran like candies so much, so Arya is going to give him some Candies. At first, Arya and Bran have 0 Candies. There are n days, at the i-th day, Arya finds ai candies in a box, that is given by the Many-Faced God. Every day she can give Bran at most 8 of her candies. If she don’t give him the candies at the same day, they are saved for her and she can give them to him later. Your task is to find the minimum number of days Arya needs to give Bran k candies before the end of the n-th day. Formally, you need to output the minimum day index to the end of which k candies will be given out (the days are indexed from 1 to n). Print -1 if she can’t give him k candies during n given days. InputThe first line contains two integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 10000). The second line contains n integers a1, a2, a3, …, an (1 ≤ ai ≤ 100). OutputIf it is impossible for Arya to give Bran k candies within n days, print -1. Otherwise print a single integer — the minimum number of days Arya needs to give Bran k candies before the end of the n-th day. ExampleInput2 31 2Output2Input3 1710 10 10Output3Input1 910Output-1NoteIn the first sample, Arya can give Bran 3 candies in 2 days. In the second sample, Arya can give Bran 17 candies in 3 days, because she can give him at most 8 candies per day. In the third sample, Arya can’t give Bran 9 candies, because she can give him at most 8 candies per day and she must give him the candies within 1 day. 这道题目需要注意思路：首先是要判断当天的糖果是不是&gt;8的，大于8就减8，并将多于糖果留给下一天，小于就减本身数量。最后通过判断是否能在规定的天数里面完成。见代码： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;int a[105];int main()&#123; int n,k,i,cnt=0,num=0; scanf("%d%d",&amp;n,&amp;k); &#123; for(i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++) &#123; cnt++; num=num+a[i]; if(num&gt;8) &#123; k=k-8; num=num-8; &#125; else &#123; k=k-num; num=0; &#125; if(k&lt;=0) break; &#125; if(i==n) cnt=-1; printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gym--100952B--New Job]]></title>
    <url>%2F2017%2F11%2F06%2FGym--100952B--New%20Job%2F</url>
    <content type="text"><![CDATA[题目This is the first day for you at your new job and your boss asks you to copy some files from one computer to other computers in an informatics laboratory. He wants you to finish this task as fast as possible. You can copy the files from one computer to another using only one Ethernet cable. Bear in mind that any File-copying process takes one hour, and you can do more than one copying process at a time as long as you have enough cables. But you can connect any computer to one computer only at the same time. At the beginning, the files are on one computer (other than the computers you want to copy them to) and you want to copy files to all computers using a limited number of cables. InputFirst line of the input file contains an integer T (1 ≤ T ≤ 100) which denotes number of test cases. Each line in the next T lines represents one test case and contains two integers N, M. N is the number of computers you want to copy files to them (1 ≤ N ≤ 1,000,000,000). While M is the number of cables you can use in the copying process (1 ≤ M ≤ 1,000,000,000). OutputFor each test case, print one line contains one integer referring to the minimum hours you need to finish copying process to all computers. ExampleInput310 107 25 3Output443NoteIn the first test case there are 10 computer and 10 cables. The answer is 4 because in the first hour you can copy files only to 1 computer, while in the second hour you can copy files to 2 computers. In the third hour you can copy files to 4 computers and you need the fourth hour to copy files to the remaining 3 computers. 这个题就是数字每次按2^0,2^1,2^2…将电脑数量相减这到题不要想复杂了，就用一个if else判断，将最大能相减的数字范围作为判断条件将电脑数减为0即可 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;int main()&#123; int T,k,N,M,count; scanf("%d",&amp;T); while(T--) &#123; count=0; k=1; scanf("%d%d",&amp;N,&amp;M); while(N&gt;0) &#123; if(k&lt;M) &#123; N=N-k; k*=2; &#125; else &#123; N=N-M; &#125; count++; &#125; printf("%d\n",count); &#125; return 0;&#125;]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式计算]]></title>
    <url>%2F2017%2F10%2F31%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[表达式计算对于我们人来说，喜欢通过中缀表达式来计算，而计算机则不一样，需要通过后缀表达式来计算，首先通过实例来介绍一下中缀表达式和后缀表达式例子中缀表达式：3（5+2）-3 6后缀表达式：3 5 2 + 3 6 - 那么转换规则是怎么样的呢？ 规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 图解可以自行百度，这里就不多加赘述了 进行表达式计算算法的实现则需要两个栈。存储数字的栈，存储字符的栈。 通过规则将表达式中的数字和字符分别存入两个栈中，如果存储在字符栈中的运算符被输出，则数字栈顶两个数字进行被输出运算符的运算（栈顶第一个数对栈顶第二个数进行操作）并将结果存入数字栈中。直到字符遍历完成，且运算符栈为空。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;stack&gt;using namespace std;stack&lt;char&gt; stack_ch;//符号栈stack&lt;int&gt; stack_num; //数值栈char str[1000]; //输入的中缀表达式char number[100]; //用来将字符串中的数字变成int型的数组void js1()//这个函数只接收+-号，+-号等级最低，运算符栈中除了括号外 都可以取出运算&#123; int num1,num2; while (stack_ch.top()!='(') //从运算符栈中取一个运算符 对数值栈顶和次顶元素进行运算 &#123; num1=stack_num.top();//取出一个数 stack_num.pop();//弹出这个数 num2=stack_num.top(); stack_num.pop(); switch (stack_ch.top()) &#123; case '+': num2+=num1; break; case '-': num2-=num1; break; case '*': num2*=num1; break; case '/': num2/=num1; break; &#125; stack_num.push(num2);//将计算结果入数值栈 stack_ch.pop();//删除已经用过的符号 &#125;&#125;void js2()//只接收 / *运算符&#123; int num1,num2; while (stack_ch.top()=='*' || stack_ch.top()=='/') //栈中只有优先级大于 &#123; num1=stack_num.top(); stack_num.pop(); num2=stack_num.top(); stack_num.pop(); switch (stack_ch.top()) &#123; case '*': num2*=num1; break; case '/': num2/=num1; break; &#125; stack_ch.pop(); stack_num.push(num2); &#125;&#125;int main()&#123; int i,k=0,s; char c[5]="."; stack_ch.push('('); gets(str); strcat(str,c);//将‘.’连接到表达式字符串中使其判断表达式字符串已读完 for (i=0;str[i];i++) &#123; if (str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')//为数字 &#123; number[k++]=str[i]; continue; &#125; number[k]='\0'; //变成字符串\0结尾 if (number[0]!='\0') &#123; s=atoi(number);//取字符串中首个数字字符所表达的数 number[0]='\0'; stack_num.push(s); //将字符串转换成整型，放入数值栈中 &#125; k=0; switch(str[i])//‘+-(’这3个符号入js1函数，入js2函数 ，优先级不同要分开计算 &#123; case '+': js1(); stack_ch.push('+'); break; case '-': js1(); stack_ch.push('-'); break; case '*': js2(); stack_ch.push('*'); break; case '/': js2(); stack_ch.push('/'); break; case '(': stack_ch.push('('); break; case ')': js1(); stack_ch.pop(); break; case '.': &#123; js1(); stack_ch.pop(); &#125; &#125; &#125; printf("%d\n",stack_num.top()); return 0;&#125;]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>前缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的存储与遍历]]></title>
    <url>%2F2017%2F10%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%82%A8%E5%AD%98%E4%B8%8E%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[###二叉树的两种储存：顺序储存 链式储存 ###四种遍历：层次遍历 前序遍历 中序遍历 后序遍历 ####1.储存 - 顺序储存： 首先用零元素将二叉树填充为完全二叉树，再将填充后的二叉树节点按层次顺序的次序储存到数组中存储后即为： 由于顺序储存效率低，所以一般不这样进行二叉树的储存。 - 链式储存： 二叉链表的结点结构为12345678template&lt;class T&gt;struct BTNode&#123; T data; BTNode *left *right ;//指向左右孩子的指针 BTNode(const T&amp; item=T(),lptr=NULL,BTNode* rptr=NULL)： data(item),left(lptr),right(rplt)&#123;&#125;&#125;; 建立二叉链表结点的函数123456789101112template&lt;class T&gt;BTNode &lt;T&gt; * GetBTNode(const T&amp; item,BTNode&lt;T&gt; *lp=NULL,BTNode&lt;T&gt; *rp=NULL)&#123; BTNode &lt;T&gt; *p; p=new BTNode&lt;T&gt; (item,lp,rp); if(p==NULL) &#123; cout&lt;&lt;"Memory allocation failure!"&lt;&lt;endl; exit(1); &#125; return (p);&#125; 图一应用举例： 1234567BTNode&lt;char&gt; *nullp = NULL;BTNode&lt;char&gt; *fp = GetBTNode('F');BTNode&lt;char&gt; *dp = GetBTNode('D', fp);BTNode&lt;char&gt; *bp = GetBTNode('B', nullp, dp);//若直接用NULL，非法，由于无法确定NULL类型BTNode&lt;char&gt; *ep = GetBTNode('E');//合法，左右孩子取，默认值BTNode&lt;char&gt; *cp = GetBTNode('C', nullp, ep);BTNode&lt;char&gt; *ap = GetBTNode('A', bp, cp); ####2.遍历 - 层次遍历：层次遍历顾名思义就是将结点一层一层的进行遍历，如例图中就为ABCDE 非递归层次遍历运用了队列，简单讲一下队列有着先进先出的原则，层次遍历可以出队之后访问，入队之前访问 出队之后访问： 1234567891011121314151617template&lt;class T&gt;void Level(const BTNode&lt;T&gt;* t)&#123; if(t==NUll) return ; queue&lt;const BTNode&lt;T&gt;*&gt; Q; Q.Push(t)//入栈函数,在queue.h内 while(!Q.Empty()) &#123; t=Q.Pop();//出栈函数，移除第一个数据并赋给t指针 cout&lt;&lt;t-&gt;data; if(t-&gt;left) Q.Push(t-&gt;left); if(t-&gt;right) Q.Push(t-&gt;right) &#125;&#125; 出队之前访问 1234567891011121314151617181920212223template&lt;class T&gt;void Level(const BTNode&lt;T&gt;* t)&#123; if(t==NUll) return ; queue&lt;const BTNode&lt;T&gt;*&gt; Q; cout&lt;&lt;t-&gt;data; Q.Push(t) while(!Q.Empty()) &#123; t=Q.Pop(); if(t-&gt;left) &#123; cout&lt;&lt;t-&gt;left-&gt;data; Q.Push(t-&gt;left); &#125; if(t-&gt;right) &#123; cout&lt;&lt;t-&gt;right-&gt;data; Q.Push(t-&gt;right); &#125; &#125;&#125; - 前序遍历 前序遍历也称之为深度优先遍历，算法的递归描述为 1.访问根节点 2.前序遍历左子树 3.前序遍历右子树 例图中前序遍历即为ABDFCE，运用了用户栈，用户栈有着先进后出的原则，在前序遍历中栈实质是为了寄存右子树的根指针，将左指针所指的左子树遍历后，再遍历右子树。代码如下： 1234567891011121314151617template &lt;class T&gt;void SimPreorder(const BTNode &lt;T&gt;* t)&#123; if(!t) return ; stack&lt;const BTNode&lt;T&gt;*&gt; S;//用户栈 while(t||!S.Empty()) if(t) &#123; cout&lt;&lt;t-&gt;data; if(t-&gt;right) S.push(t-&gt;right);//入栈 t=t-&gt;left; &#125; else t=S.Pop();//清除栈的最后进入的一位&#125; 关于前序遍历，有些算法和它还是很相近的，比如二分快速排序，集合幂集求解。后期会补上相关博客 - 中序遍历中序遍历中，也用到栈，其意义是寄存根节点，以便于左子树遍历完成后取出根指针，访问根指针并取出右子树进行遍历，算法的递归描述：1.中序遍历左子树2.访问根节点3.中序遍历右子树代码如下： 123456789101112131415161718192021template&lt;class T&gt;void Siminorder(const BTNode&lt;T&gt;* t)&#123; if(!t) return ; stack&lt;const BTNode&lt;T&gt;*&gt; S; while (t||!S.Empty()) &#123; if(t) &#123; S.Push(t); t=t-&gt;left' &#125; else &#123; t=S.Pop(); cout&lt;&lt;t-&gt;data; t-t-&gt;right; &#125; &#125;&#125; - 后序遍历后序遍历非递归算法任然是栈来实现，但是不同的是后序遍历用了两个栈，一个栈是为了寄存根节点，一个栈是为了记录相应的结点指针入栈的次数，后序遍历结点会进栈两次，第一次遍历左子树，第二次为了遍历右子树 递归算法描述：1.后序遍历左子树2.后序遍历右子树3.访问根节点 代码实现： 1234567891011121314151617181920212223242526272829303132template&lt;class T&gt;void SimPostorder(const BTNode&lt;T&gt;* t)&#123; if (!t) return ; int tag; Stack&lt;const BTNode&lt;T&gt;*&gt; S; Stack&lt;int&gt; tagS; const BTNode &lt;T&gt;*temp; while (t || !S.Empty()) &#123; if (t) &#123; S.Push(t); tagS.Push(1); t = t-&gt;left; &#125; else &#123; temp = S.Pop(); tag = tagS.Pop(); if (tag == 1) &#123; S.Push(temp); tagS.Push(2); t = temp-&gt;right; &#125; else cout &lt;&lt; temp-&gt;data; &#125; &#125;&#125; 记录的还是有些粗略，后期会再进行详解 注： 片段代码或者语言如有错误望谅解并请指出。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>二叉树的顺序存储</tag>
        <tag>二叉树的链式存储</tag>
        <tag>层次遍历</tag>
        <tag>前序遍历</tag>
        <tag>中序遍历</tag>
        <tag>后序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在ubuntu17.04下安装最新版QQ教程]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%9C%A8ubuntu17.04%E4%B8%8B%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88QQ%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[博客更新：2018年7月25日好久没有登陆csdn，今天发现这篇文章帮助了这么多人，百度云链接更新了同时给大家分享一个更为简单的安装wine QQ 的教程 ，也是几个月前摸索出来的，非常简单！见文章链接 Ubuntu18.04超级简单的安装wine QQ教程Ubuntu18.04安装WPS(亲测~)使用的方式是通过wine这一强大的工具,wine是什么就自行百度啦，我也是近期接触linux 具体教程：1.安装wine首先ctrl+alt+T打开终端进行如下三条指令 123sudo add-apt-repository ppa:wine/wine-buildssudo apt-get updatesudo apt-get install winehq-devel 2.下载安装包百度云链接：https://pan.baidu.com/s/1dE2sZNr 密码: evgf(大家看看文头的新方法嘻嘻) 3.解压安装下载完成之后，进入到下载目录，将其解压到我们的用户主home目录下（图片文件右键提取）,解压出来的是3个隐藏目录和说明文件其实这个时候就已经安装好了，这个时候只用按下super键（Win键）搜索qq，就会出现wineqq，然后可能会弹出更新安装，（我出现了）点安装就ok。最后就会弹出qq登录界面就可以登录啦完美解决～ 当然还有卸载qq的方法啦卸载qq的方法：1234567rm -rf ~/.winerm -rf ~/.local/share/applications/wine-QQ.desktoprm -rf ~/.local/share/icons/hicolor/256x256/apps/QQ.pngrm -rf ~/.fonts/simsun.ttc]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>wine qq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂--斐波那契数列]]></title>
    <url>%2F2017%2F10%2F10%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82--%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[求斐波那契数列有很多种方法，暴力，递归，矩阵快速幂等等但是前两者在所求项过大时会导致运行时间内存过大，矩阵快速幂恰恰解决了这两个弊端矩阵快速幂包含快速幂思想和些许线性代数知识来达到快速运算的目的首先我们来了解一下相关线性代数知识：矩阵A*矩阵B=矩阵C 由图中所表示的可以理解为 f（x+1）=f（x）+f（x-1）即斐波那契数列的通式若要求项数较大的数n斐波那契数，那么只用将矩阵A进行n-1次幂运算 算法实现包括包括： 构建表示矩阵的结构体，矩阵乘法的实现，矩阵快速幂 - 构建表示矩阵的结构体 12345678struct matrix&#123; long long mat[10][10]; matrix() &#123; memset(mat, 0 ,sizeof(mat)); &#125;&#125; 由于斐波那契数列中的数值会超出int的范围，所以此处用了 long long ，构造函数是将数据初始化为0 - 矩阵乘法的实现1234567891011matrix mul(matrix A,matrix B)&#123; matrix C; for(int i=1;i&lt;10;i++) for(int j=1;j&lt;10;j++) for(int k=1;k&lt;10;k++) &#123; C.mat[i][j]=A.mat[i][K]*B.mat[k][j]+C.mat[i][j] &#125; return C; &#125; 矩阵乘法很好实现，用三层循环就可以实现 - 矩阵快速幂1234567891011121314matrix quickmi（matrix A,long long n）&#123; matrix B; for(int i=1;i&lt;10;i++) B.mat[i][i]=1; while (n&gt;0) &#123; if(n&amp;1) B=mul(A,B); A=mul(A,A); n&gt;&gt;=1; &#125; return B;&#125; 矩阵快速幂和普通快速幂是一样的思想，只是将基数由实数变成矩阵进行快速运算 如果不是很了解快速幂，可以看看这个博客快速幂 注： 片段代码或者语言如有错误望谅解并请指出。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2017%2F10%2F03%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[快速幂是个好东西 ，有时候一些题目需要求高次幂（例如：2^100）的运算或者大量的递归运算（斐波那契数列）就基本和下面两个死敌说拜拜了Time limit exceeded←死敌Memory Limit Exceeded←死敌（还有WA）切入正题——-——-——-——-——-——-——-——-——-——-——-——-——-——-——-——-—— 首先我们先看看快速幂的优势在哪？ 例：2^254常规运算需要将2连乘254次（2 2 … 2 2）而254二进制表示为11111110（254=0 2^0 + 1 2^1 + 12^2 …+ 1 2^8 ）所以2^254=2^(0 2^0 + 1 2^1 + 12^2 …+ 1 2^8)=2^(2^1) 2^(2^2)… * 2^(2^8)此时运算只用进行7次 但是如何将十进制的幂次转换为二进制呢？那我们就需要运用到位运算中的：1.&amp; 按位与运算符2.&gt;&gt;右移运算符1.按位与运算符我们就简单的运用一下来判断末位是否为1，例如11111111&amp;1=1，11111110&amp;1=0而原因就是使位数为0的项给剔除掉 如例子中的2^254 是为了减少了首项0*2^0这一项的运算2.右移运算符刚刚通过按位与运算符判断了末位是否为1，但事实上我们要将所有数都进行判断，那么就要运用到右移运算符。例如11111110&gt;&gt;1则为01111111，11111110&gt;&gt;2则为00111111，高位补0，低位去除。所以我们就用到&gt;&gt;1来达到移位进行判断。 代码如下a为基数，b为次幂数1234567891011int FastPower(int a,int b)&#123; int ans=1,vis=a; while(b!=0) &#123; if(b&amp;1==1) ans=ans*vis; vis=vis*vis;//无论当前位是否为1，都需要进行，为后续进行储备 b&gt;&gt;=1; //b/=2; &#125; return ans;&#125; 正因为vis*vis，使得次幂会以2 4 8 16……（2^1 2^2 2^3 2^4……）上升对应着二进制数所对应的十进制数从而达到快速运算的成效。快速幂的基本思想就是这样啦 注： 片段代码或者语言如有错误望谅解并请指出。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uva-1339 Ancient Cipher]]></title>
    <url>%2F2017%2F10%2F02%2FUva-1339%20%20Ancient%20Cipher%2F</url>
    <content type="text"><![CDATA[Uva-1339题目链接 题意对比两串字符串，如果一字符串内所有字母与另一字符串的字母是一一映射替换的，且相同字母替换的字母也相同，如果是就输出YES,否则输出NO 过程这个题目表面上是字符匹配的问题，其实只是排序问题，将字符串的相同的字母进行计数存入到数组中，只要保证相同的字母个数相同就可以判断：一字符串内所有字母与另一字符串的字母是一一映射替换的，且相同字母替换的字母也相同，这里就对字符的ASCLL数值进行操作，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char str[105],str1[105];int main()&#123; int k,a[26],b[26],flag; while(gets(str)) &#123; flag=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); int len=strlen(str); for(int i=0;i&lt;len;i++) &#123; k=str[i]-'A'; a[k]++; &#125; gets(str1); for(int i=0;i&lt;len;i++) &#123; k=str1[i]-'A'; b[k]++; &#125; sort(a,a+26);//排序 sort(b,b+26); for(int i=0;i&lt;26;i++) &#123; if(a[i]!=b[i]) flag=0; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 代码中使用了sort函数，这个函数可以进行快速排列，有关sort函数会单独写一篇博客后期补上链接 注： 片段代码或者语言如有错误望谅解并请指出。]]></content>
      <categories>
        <category>编程题</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数塔]]></title>
    <url>%2F2017%2F09%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92--%E6%95%B0%E5%A1%94%2F</url>
    <content type="text"><![CDATA[数塔是动态规划的一道经典题认识数塔前，先认识一下动态规划，动态规划不是一种特定的算法，而是一种具有较强的技巧性的手段，或者说是思想，但所有动态规划的题离不开两个核心：1.状态2.状态转移方程当我们抓住这两个核心，我们的问题就能解决一大半！—————————————————————————————————————题目：图片上便是一个数塔，现在要解决的问题是，从数塔顶层到底层，沿途将权重（即数值）相加和最大是多少？ 分析：首先再回想一遍动态规划的两个核心。状态分析：我们会发现，当在每个节点都会做一个选择，（例如：在1时，是选择左还是选择右）而选择了左或者右的时候又继续会有选择，我们此时马上就会想到递归（见a）状态转移方程分析：题目要求最大的走法，所以我们可以初步得出一个方程雏形a[选择后的结果]=b[节点]+max(a[左],a[右])现在就需要一点点技巧性了，如何将方程雏形改成真正的状态转移方程此处我们给出一个二维数组的处理办法，如图所示： 即可得出状态转移方程：a[i,j]=b[i,j]+max(a[i+1,j],a[i+1,j+1])理解了题目的状态，得出状态转移方程后，便要考虑计算的问题了 - a -递归计算！！注意边界处理，递归没有什么要讲的，直入代码1234567int dp(int i,int j)&#123; if(i&lt;=n) return b[i,j]+max(dp(i+1,j),dp(i+1,j+1)) if(i&gt;n) return 0;&#125; 例子代码：1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[105][105],m;int dp(int i,int j)&#123; if(i&lt;=m) return a[i][j]+(max(dp(i+1,j),dp(i+1,j+1))); if(i&gt;m) return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; printf("%d",dp(1,1)); &#125; return 0;&#125; 递归算法保证子结构为最优解，所以上一结构也是最优，所以可以得出最大数值路径，但是会产生大量的重复计算，如图片2中会将（3，2）（4，2）（4，3）重复计算两次，如果数塔层数过大，那么效率是很低的，所以孕育而生了递推计算（见b） 记忆化搜索（见c） - b递推计算！！边界处理，递推采用的是一种逆向思维，从数塔最后一层进行处理，比递归计算处理更加的简洁，在大多数情况下（每个决策时间一样），递推法的时间复杂度是：状态总数×每个状态的决策个数×决策时间。 123456789for(int i=1;i&lt;m;i++) b[m][i]=a[m][i];for(int i=m-1;i&gt;=1;i--)&#123; for(int j=1;j&lt;=i;j++) &#123; b[i][j]=a[i][j]+max(b[i+1][j],b[i+1][j+1]); &#125;&#125; 例子代码：123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[105][105];int b[105][105];int m;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; for(int i=1;i&lt;=m;i++) b[m][i]=a[m][i]; for(int i=m-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; b[i][j]=a[i][j]+max(b[i+1][j],b[i+1][j+1]); &#125; &#125; printf("%d",b[1][1]); &#125; return 0;&#125; - c记忆化搜索记忆化搜索是递归的优化版本，利用另一个数组将处理过的数组记录，达到优化目的记录处理：利用memset(b,－1,sizeof(b))将b[ ][ ]数组都初始化为-1，当数组进行过处理直接返回当前数值即可 123456789int dp(int i,int j)&#123; if(b[i][j]&gt;=0) return b[i][j]; if(i&lt;=m) b[i][j]=a[i][j]+max(dp(i+1,j),dp(i+1,j+1)); if(i&gt;m) return 0;&#125; 例子代码和递归没多大差别，就是要注意每次进行需要将数组b[][]进行初始化为-1为下一次计算做准备递归与记忆化搜索的区别 见下图： 图示已将优化体现的很明显了~ 注：1.片段代码或者语言如有错误望谅解并请指出。2.图摘自算法竞赛入门经典第二版，侵权请联系博主删除。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列之和]]></title>
    <url>%2F2017%2F09%2F27%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题简介：求最大连续序列之和。例如：{-1，5，6，-10，15，-9，8}，最大连续子序列和为{5，6，-10，15}，和为16。代码： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn]; //存入序列int b[maxn]; //存储状态 int main() &#123; int m; scanf("%d",&amp;m); for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;a[i]); &#125; //录入样例&#123;-1，5，6，-10，15，-9，8&#125; b[0] = a[0]; int ans = b[0]; for(int i = 1;i&lt;m ; i++) &#123; b[i]=max(a[i],b[i-1]+a[i]); //讲解见a if(ans&lt;b[i]) ans=b[i]; //ans储存最大序列之和 &#125; printf("max %d\n" , ans); for(int i = 0;i&lt;m;i++) //展现状态b[i]每个位置状态 printf("b[%d]=%d\n",i,b[i]); return 0; &#125; a状态转移方程 b[i]=max(a[i],b[i-1]+a[i]) b[i]每个状态为当前序号之前的最大子序列之和，max（）函数将进行选择：1.删除前一状态 a[i] 例如：b[1]=max(a[1],a[1]+b[0]);2.保留前一个状态 b[i-1]+a[i] 例如：b[2]=max(a[2],a[2]+b[1]); 最后用ans将最大的那个状态保存即求出了最大子序列之和]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
