<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU1323]]></title>
    <url>%2F2018%2F09%2F06%2FHDU1232%2F</url>
    <content type="text"><![CDATA[畅通工程Time Limit: 4000/2000 MS (Java/Others)Memory Limit: 65536/32768 K (Java/Others) Problem Description：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input：测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说 3 3 1 2 1 2 2 1 这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output：对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input4 2 1 3 4 3 3 3 1 2 1 3 2 3 5 2 1 2 3 5 999 0 0 Sample Output1 0 2 998]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集详解]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集（Union-find Sets）是一种非常巧妙而且实用的数据结构，主要用于处理一些不想交的集合合并问题。具体包含了两个函数：Union()用来合并和Find()用来查找 以及一个整型数组用来记录每个点的前导点是什么。 代码实现int pre[1050]//记录第i个节点的父亲节点 int Find(int root)//查找根节点 { int son,temp; son=root; while(root != pre[root]){//寻找父亲节点 root = pre[root]; } while(son != root){//路径压缩 temp=pre[son]; pre[son]=root; son=temp; } return son; } void Union(int root1,int root2){//判断是否连通，不连通就合并 int x,y; x=Find(root1); y=Find(root2); if(x!=y)//如果不连通，就把它们所在的连通分支合并 pre[x] = y; } 算法详解pre[]数组最开始初始化为为pre[i]=i，即表明这pre[i]的父亲节点是i，Union()函数则是将两个节点进行联通，其中Union中用到了Find()函数是找自己的父亲节点判断是否联通，如果不连通就进行pre[x]=y操作，表示为将x节点的父亲节点设置为y。其中Find()函数通过递归判断本节点的上一节点的父亲节点是不是本身，直到找到一个节点的父亲节点是本身的节点作为父亲节点。 在Find()函数中有一个路径压缩算法，是由于Union()函数只是为了连接，所以谁作为父亲节点是随机的，因此最后的树状结构可能很复杂，查找的效率就很低，那么就需要进行路径压缩，让所有的父子节点关系都变成两级结构。 经典例题传送门： HDU 1232畅通工程]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Jos’s blog! This is my first post.]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>hi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列之和]]></title>
    <url>%2F2017%2F09%2F27%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[问题简介：求最大连续序列之和。例如：{-1，5，6，-10，15，-9，8}，最大连续子序列和为{5，6，-10，15}，和为16。代码： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn]; //存入序列int b[maxn]; //存储状态 int main() &#123; int m; scanf("%d",&amp;m); for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;a[i]); &#125; //录入样例&#123;-1，5，6，-10，15，-9，8&#125; b[0] = a[0]; int ans = b[0]; for(int i = 1;i&lt;m ; i++) &#123; b[i]=max(a[i],b[i-1]+a[i]); //讲解见a if(ans&lt;b[i]) ans=b[i]; //ans储存最大序列之和 &#125; printf("max %d\n" , ans); for(int i = 0;i&lt;m;i++) //展现状态b[i]每个位置状态 printf("b[%d]=%d\n",i,b[i]); return 0; &#125; a状态转移方程 b[i]=max(a[i],b[i-1]+a[i]) b[i]每个状态为当前序号之前的最大子序列之和，max（）函数将进行选择：1.删除前一状态 a[i] 例如：b[1]=max(a[1],a[1]+b[0]);2.保留前一个状态 b[i-1]+a[i] 例如：b[2]=max(a[2],a[2]+b[1]); 最后用ans将最大的那个状态保存即求出了最大子序列之和]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
